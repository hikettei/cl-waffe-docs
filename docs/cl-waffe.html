<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
  cl-waffe &ndash; cl-waffe
</title>
    <link rel="stylesheet" href="static/style.css"/>
    
  <link rel="stylesheet" href="static/highlight.css"/>
  <script src="static/highlight.js"></script>
  <style>
   /* Highlight the current top-level TOC item, and hide the TOC of all other items */

   .toc a[data-node="cl-waffe"] {
       /*color: #AD3108;*/
   }

   .toc ol {
       display: none;
   }

   .toc li a[data-node="cl-waffe"] {
       font-weight: bold;
   }

   .toc li a[data-node="cl-waffe"] + ol {
       display: block;
   }

   .toc li a[data-node="cl-waffe"] + ol li {
       margin-left: 10px;
   }
  </style>

  </head>
  <body>
    
  <h1 class="doc-title">cl-waffe</h1>
  <article id="article" data-section="cl-waffe">
    <aside>
      <ol class="toc"><li><a href="overview.html" data-node="overview">Overview</a><ol><li><a href="overview.html#welcome-to-cl-waffe!" data-node="welcome-to-cl-waffe!">Welcome to cl-waffe!</a></li><li><a href="overview.html#todo-list-and-problems" data-node="todo-list-and-problems">Todo List And Problems</a></li><li><a href="overview.html#pull-requests" data-node="pull-requests">Pull Requests</a></li><li><a href="overview.html#contacts" data-node="contacts">Contacts</a></li><li><a href="overview.html#lla-setting" data-node="lla-setting">LLA Setting</a></li><li><a href="overview.html#when-memory-exhausted" data-node="when-memory-exhausted">When Memory Exhausted</a></li></ol></li><li><a href="basics.html" data-node="basics">Basics</a><ol><li><a href="basics.html#first" data-node="first">First</a></li><li><a href="basics.html#define-your-model" data-node="define-your-model">Define Your Model</a></li><li><a href="basics.html#define-your-dataset" data-node="define-your-dataset">Define Your Dataset</a><ol><li><a href="cl-waffe's-dataset--waffedataset.html" data-node="cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</a></li></ol></li><li><a href="basics.html#train-your-model" data-node="train-your-model">Train Your Model</a></li></ol></li><li><a href="advanced.html" data-node="advanced">Advanced</a><ol><li><a href="advanced.html#exported" data-node="exported">Exported</a></li></ol></li><li><a href="basic-tensor-operations.html" data-node="basic-tensor-operations">Basic Tensor Operations</a><ol><li><a href="basic-tensor-operations.html#0-basic-tensor-operations" data-node="0-basic-tensor-operations">Basic Tensor Operations</a></li></ol></li><li><a href="cl-waffe.html" data-node="cl-waffe">cl-waffe</a><ol><li><a href="cl-waffe.html#package--cl-waffe" data-node="package--cl-waffe">Package: cl-waffe</a></li><li><a href="cl-waffe.html#defining-objects" data-node="defining-objects">Defining objects</a></li><li><a href="cl-waffe.html#documents-in-cl-waffe's-object" data-node="documents-in-cl-waffe's-object">Documents in cl-waffe's object</a></li><li><a href="cl-waffe.html#tensor" data-node="tensor">Tensor</a><ol><li><a href="cl-waffe.html#basic-of-tensor-and-backward" data-node="basic-of-tensor-and-backward">Basic of Tensor and backward</a><ol><li><a href="cl-waffe.html#initialize-tensor" data-node="initialize-tensor">Initialize Tensor</a><ol><li><a href="cl-waffe.html#parameters" data-node="parameters">Parameters</a></li><li><a href="cl-waffe.html#constants" data-node="constants">Constants</a></li><li><a href="cl-waffe.html#tensor-vs-const" data-node="tensor-vs-const">Tensor vs Const</a></li></ol></li></ol></li><li><a href="cl-waffe.html#forward-nodes" data-node="forward-nodes">Forward Nodes</a></li><li><a href="cl-waffe.html#exported-parameters" data-node="exported-parameters">Exported Parameters</a></li><li><a href="cl-waffe.html#types" data-node="types">Types</a></li><li><a href="cl-waffe.html#accessor" data-node="accessor">Accessor</a></li></ol></li><li><a href="cl-waffe.html#initialize-constants" data-node="initialize-constants">Initialize Constants</a></li><li><a href="cl-waffe.html#cut-and-displace-tensor" data-node="cut-and-displace-tensor">Cut and Displace Tensor</a></li><li><a href="cl-waffe.html#shaping" data-node="shaping">Shaping</a></li><li><a href="cl-waffe.html#operations" data-node="operations">Operations</a></li><li><a href="cl-waffe.html#math-functions" data-node="math-functions">Math Functions</a></li><li><a href="cl-waffe.html#activations" data-node="activations">Activations</a></li><li><a href="cl-waffe.html#utils-for-defnode" data-node="utils-for-defnode">Utils for defnode</a></li><li><a href="cl-waffe.html#train-and-valid" data-node="train-and-valid">Train And Valid</a></li><li><a href="cl-waffe.html#datasets" data-node="datasets">Datasets</a><ol><li><a href="1-cl-waffe's-dataset--waffedataset.html" data-node="1-cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</a></li></ol></li></ol></li><li><a href="cl-waffe.nn.html" data-node="cl-waffe.nn">cl-waffe.nn</a><ol><li><a href="models.html" data-node="models">Models</a><ol><li><a href="cl-waffe's-model--embedding.html" data-node="cl-waffe's-model--embedding">cl-waffe's Model: Embedding</a></li><li><a href="2-cl-waffe's-model--embedding.html" data-node="2-cl-waffe's-model--embedding">cl-waffe's Model: Embedding</a></li><li><a href="cl-waffe's-model--rnn.html" data-node="cl-waffe's-model--rnn">cl-waffe's Model: RNN</a></li></ol></li><li><a href="aggregations.html" data-node="aggregations">aggregations</a><ol><li><a href="cl-waffe's-node--dropout.html" data-node="cl-waffe's-node--dropout">cl-waffe's Node: Dropout</a></li><li><a href="cl-waffe's-model--batchnorm2d.html" data-node="cl-waffe's-model--batchnorm2d">cl-waffe's Model: BatchNorm2d</a></li></ol></li><li><a href="losses.html" data-node="losses">losses</a></li></ol></li><li><a href="cl-waffe.optimizers.html" data-node="cl-waffe.optimizers">cl-waffe.optimizers</a><ol><li><a href="sgd.html" data-node="sgd">SGD</a><ol><li><a href="cl-waffe's-optimizer--sgd.html" data-node="cl-waffe's-optimizer--sgd">cl-waffe's Optimizer: SGD</a></li></ol></li><li><a href="momentum.html" data-node="momentum">Momentum</a><ol><li><a href="cl-waffe's-optimizer--momentum.html" data-node="cl-waffe's-optimizer--momentum">cl-waffe's Optimizer: Momentum</a></li></ol></li><li><a href="adagrad.html" data-node="adagrad">AdaGrad</a><ol><li><a href="cl-waffe's-optimizer--adagrad.html" data-node="cl-waffe's-optimizer--adagrad">cl-waffe's Optimizer: AdaGrad</a></li></ol></li><li><a href="rmsprop.html" data-node="rmsprop">RMSProp</a><ol><li><a href="cl-waffe's-optimizer--rmsprop.html" data-node="cl-waffe's-optimizer--rmsprop">cl-waffe's Optimizer: RMSProp</a></li></ol></li><li><a href="adam.html" data-node="adam">Adam</a><ol><li><a href="cl-waffe's-optimizer--adam.html" data-node="cl-waffe's-optimizer--adam">cl-waffe's Optimizer: Adam</a></li></ol></li></ol></li><li><a href="cl-waffe.io.html" data-node="cl-waffe.io">cl-waffe.io</a><ol><li><a href="3-exported.html" data-node="3-exported">Exported</a></li></ol></li><li><a href="cl-waffe.caches.html" data-node="cl-waffe.caches">cl-waffe.caches</a><ol><li><a href="4-exported.html" data-node="4-exported">Exported</a></li></ol></li></ol>
    </aside>
    <main class="codex-section">
      <header>
        <h2 class="section-title">cl-waffe</h2>
      </header>
      <div class="content">
        <p>
</p><h1 id="package--cl-waffe">Package: cl-waffe</h1><p>
This package is under development and APIs can be changed without notice.</p><p>There's
</p><ol><li>WaffeTensor and APIs for it</li><li>Macros for defining objects</li><li>Train Function</li><li>Basic Tensor Operations</li></ol><p>
</p><h1 id="defining-objects">Defining objects</h1><p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defmodel</code><code class="codex-lambda-list">(name args &amp;key (parameters nil) (forward (quasiquote ((&amp;rest args) (error :forward isn't defined.)))) (optimize nil) (document An model, defined by cl-waffe))</code><div class="codex-docstring"><p>This macro defines a cl-waffe model as <code class="codex-param">name</code>.</p><p>At the same time, a constructor <code class="codex-param">name</code> is defined and you can initialize your model like:</p><pre><code class="lisp">(cl-waffe.nn:LinearLayer 100 20) ; =&gt; [Model: Linearlayer]
</code></pre><p>
</p><dl><dt>name</dt><dd>Your model and constructor name</dd><dt>args</dt><dd>The arguments of a constructor</dd><dt>parameters</dt><dd><p>The parameters your model has.</p><p>Every time you initialize the model, the parameters are initialized.</p><p>Note that <code class="codex-param">defmodel</code> behaves like class.</p><p>The arguments are the same as <a href="http://l1sp.org/cl/defstruct"><code>defstruct</code></a></p><p>Format Example: ((param-name param-initial-value &amp;key (type your-type)))</p></dd><dt>optimize</dt><dd>when t, your forward slot is defined with (declare (optimize (speed 3)(space 0)(debug 0))). It helps faster training after you ensured debugged.</dd><dt>forward</dt><dd><p>Define here the forward propagation of your model.</p><p>When backward, <b>Automatic differentiation applies</b>.</p></dd></dl><p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defnode</code><code class="codex-lambda-list">(name args &amp;key parameters forward backward optimize (regard-as-node t) (document An node, defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining computation nodes.</p><p>defnode is useful when you want to define the derivative yourself.<b>Note that parameter tensors in :parameter won't updated by optimizers.</b></p><p>If you want to update params, define additional models.</p><dl><dt>regard-as-node</dt><dd>When the slot :regard-as-node is nil, an optimizer in cl-waffe.caches regards this as model (i.e. argument could be destructed.) Default is t.
</dd></dl><p>Note that:</p><ol><li>:backward must return list, where that length corresponds with the length of input's argument, otherwise an error occurs when backward.</li><li>In forward and backward, computation node isn't needed to be continuous.However, the last values of :forward and :backward step, must posses :thread-data, which can be obtained by (waffetensor-thread-data tensor)</li></ol><p>Example:</p><pre><code class="lisp">(defnode AddTensor nil
  :optimize t
  :parameters nil
  :forward  ((x y)
	     (with-searching-calc-node :add x y))
  :backward ((dy)(list dy dy)))

(call (AddTensor) tensor1 tensor2)
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defoptimizer</code><code class="codex-lambda-list">(name args &amp;key parameters update optimize (document An optimizer, defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining optimizers. Internally, This is paraphase of defmodel, which slot names are just different.</p><p>Note: by calling :backward slot, optimizers work as (zero-grad).</p><dl><dt>Name</dt><dd>The optimizer's structure and constructor will be defined based on name</dd><dt>Args</dt><dd>Initializer of the optimizer. The first value of initializer is the hash-table that collected model's parameter where the key is fixnum from 0 to n. You have to store it.</dd><dt>parameters</dt><dd>An parameters that it has.</dd><dt>update</dt><dd>when training and (update) is called, this slot is called and you optimizer your parameters.</dd><dt>optimize</dt><dd>when t, the :update slot is defined with (optimize (speed 3)(space 0)(debug 0)) Default: nil</dd><dt>document</dt><dd>docstring for optimizers. You can use string or (with-usage) macro</dd></dl><p>Example:</p><pre><code class="lisp">;defoptimizer's args must start with params (symbol-name doesn't matter) which receives hash-table whose key is 1..n

(defoptimizer SGD (params &amp;key (lr 1e-3))
  :optimize t
  :parameters ((params params :type hash-table)
               (lr lr :type single-float))
  :update (()
       (dotimes (i (hash-table-count (self params)))
         ; W(n+1) = W(n) - n * grad
         (!modify (gethash i (self params))) :+=
               (!mul (self lr)(grad (gethash i (self params)))))))

</code></pre><p>
</p></div></div></p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defdataset</code><code class="codex-lambda-list">(name args &amp;key parameters next length (document An dataset structure defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining dataset. (This is kinda pytorch's dataloader)</p><p>The slots you defined can be invoked by using (get-dataset dataset index)(get-length dataset).</p><dl><dt>parameters</dt><dd>parameters datasets have.</dd><dt>next</dt><dd>when function (get-dataset dataset index) is called, this slot invokes. Return waffetensor for the next batch in response to your task.</dd><dt>length</dt><dd>In this form, the function must return the total length of your datasets where the value is fixnum. (Not a batch, and not a current index.)</dd></dl><pre><code class="lisp">(defdataset Mnistdata (train valid batch-size)
  :parameters ((train train)(valid valid)(batch-size batch-size))
  :next    ((index)
	    (list (!set-batch (self train) index (self batch-size))
		  (!set-batch (self valid) index (self batch-size))))
  :length (()(car (!shape (self train)))))

</code></pre><p>cl-waffe excepts index to be 1, 2, 3, ... (dataset-maxlen)</p><p>So, please manage batch-sizes in args and :next slots.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">get-dataset</code><code class="codex-lambda-list">(dataset index)</code><div class="codex-docstring">Get datum of the index from dataset.
Input: dataset ... dataset defined by defdataset.
       index ... fixnum</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">get-dataset-length</code><code class="codex-lambda-list">(dataset)</code><div class="codex-docstring">Get total size of your dataset.</div></div></p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">deftrainer</code><code class="codex-lambda-list">(name args &amp;key model optimizer optimizer-args step-model predict (document An trainer structure defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining trainer, which is made in order to call <code class="codex-param">train</code> function.</p><p>The slots you defined can be invoked by using <code>(step-model model &amp;rest args)</code>, <code>(predict model &amp;rest args)</code>. See below.</p><p>
</p><dl><dt>model</dt><dd>An model defined by <code>(defmodel)</code> which you want to train.</dd><dt>optimizer</dt><dd>An optimizer defined by <code>(defoptimizer)</code></dd><dt>optimizer-args</dt><dd>An arguments for optimizer</dd><dt>step-model</dt><dd>For each batch step, :step-model is called in <code>(train)</code> function. Describe here forward step, backward, zero-grad, update for training.</dd><dt>predict</dt><dd>an code for predicting</dd></dl><p>
These macro below are defined by <a href="http://l1sp.org/cl/macrolet"><code>macrolet</code></a> and you can use them in :step-model, :predict</p><dl><dt>(self name)</dt><dd>access trainer's parameters.</dd><dt>(model)</dt><dd>access trainer's model, defined by :model keyword.</dd><dt>(zero-grad)</dt><dd>Find model's all parameters and constants, and initialize their grads. (i.e. call optimizer's backward)</dd><dt>(update)</dt><dd>Find model's all parameters, and call optimizer and change parameter's data. (i.e. call optimizer's forward)</dd></dl><p>This trainer macro is defined in order to integrate following works:</p><ol><li>calling models</li><li>calling criterions</li><li>calling backward</li><li>calling optimizer</li><li>calling zero-grad</li><li>defining predict</li></ol><p>Example:</p><pre><code class="lisp">(deftrainer MLPTrainer (activation lr)
  :model          (MLP activation)
  :optimizer      cl-waffe.optimizers:Adam ; Note: :optimizer requires a single variable.
  :optimizer-args (:lr lr) ; these arguments directly expanded to optimizer's args.
  :step-model ((x y)
	       (zero-grad) ; call zero-grad
	       (let ((out (cl-waffe.nn:softmax-cross-entropy (call (model) x) y))) ; get criterion
		 (backward out) ; backward
		 (update) ; call optimizer
		 out)) ; return loss
 :predict ((x)(call (model) x))) ;for predict

(setq trainer (MLPTrainer :relu 1e-4)) ; init your trainer

; Train:   (step-model trainer model-input-x model-input-y)
; Predict: (predict trainer model-input-x)

</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">step-model</code><code class="codex-lambda-list">(trainer &amp;rest args)</code><div class="codex-docstring"><p>An function for calling trainer object defined by deftrainer
By using this function, trainer's step-model will be invoked.</p><p>Input: Trainer, Args</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">predict</code><code class="codex-lambda-list">(trainer &amp;rest args)</code><div class="codex-docstring">An function for calling trainer's predict slot</div></div>
</p></p><h1 id="documents-in-cl-waffe's-object">Documents in cl-waffe's object</h1>

<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-usage</code><code class="codex-lambda-list">(object-name &amp;key (overview Nothing) (args describe like &amp;rest this) (forward Nothing) (step-args describe like &amp;rest this) (backward Nothing) (update Nothing) (step-model Nothing) (predict Nothing) (next Nothing) (length Nothing) (note ))</code><div class="codex-docstring"><p>In :document slot, (for `defmodel, defnode, defoptimizer deftrainer defdataset`) this macro will be useful.</p><p>Keyword:
   step-args, arguments for :forward or :step-model, :next.</p><p>cl-waffe automatically generate docstrings.</p><p>Todo:Write Docs</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">build-docstring</code><code class="codex-lambda-list">(usage object-type)</code><div class="codex-docstring"><p>Build docstring based on usage and object-type</p><p>Todo: Write Doc</p></div></div>

<h1 id="tensor">Tensor</h1><h2 id="basic-of-tensor-and-backward">Basic of Tensor and backward</h2><h3 id="initialize-tensor">Initialize Tensor</h3><p>
Choose your data structure as follows:</p><dl><dt>use grads</dt><dd>=&gt; Initialize with (tensor ) or (parameter )</dd><dt>don't use grads</dt><dd>=&gt; Initialize with (const )</dd></dl><h4 id="parameters">Parameters</h4><pre><code class="lisp">(tensor 0) ; =&gt; #Parameter{0 :device :MGL :backward NIL}
(parameter (!zeros '(10 10)))
; =&gt; #Parameter{((0.0 0.0 ~ 0.0 0.0)            
;                         ...
;            (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10) :device :MGL :backward NIL}

(setq mat (make-mat '(10 10)))
(tensor mat) ;the save as above
</code></pre><h4 id="constants">Constants</h4><pre><code class="lisp">(const 0) ; =&gt; #Const(0)
(!zeros '(10 10)) ; =&gt;
;#Const(((0.0 0.0 ~ 0.0 0.0)        
;                 ...
;        (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))

(setq mat (make-mat '(10 10)))
(const mat) ; the same as above
</code></pre><h4 id="tensor-vs-const">Tensor vs Const</h4>
The differences between Tensor and Const are as follows
<ol><li>Calling (backward out) function, and (grad tensor) get new grads-value while (grad const) doesn't</li><li>Calling optimizers will modify the model's parameters where param is a tensor, while const isn't.</li></ol>
<p>
</p><p>In order to make constants an parameter, use this:
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">parameter</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Redefining new-tensor where old-tensor is const or tensor.</p><p>The new-tensor can made grads.</p><p>Excepted usage is like:
</p><pre><code class="lisp">(setq my-param (parameter (!mul 0.01 (!randn `(10 10)))))
</code></pre><p>Note that: tensor's computation node that old-tensor has, will be lost. Only tensor's data and backend will be extended.</p><dl><dt>Input</dt><dd>Tensor (as usual, defined by (const)(sysconst)(tensor))
</dd><dt>Output</dt><dd>Tensor (as usual, defined by (tensor))
</dd></dl></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">detach</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Expanded to (const (data tensor)).</p><p>Note: this macro doesn't clone data itself</p></div></div>
</p><p>Here's structure of waffetensor
<div class="codex-doc-node codex-record codex-structure"><code class="codex-name">waffetensor</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Constructor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(sysconst value &amp;key (backend *default-backend*) (extend nil) (thread-data nil) (path-through-node? nil) &amp;aux (data (init-waffe-tensor-data value)) (backend (check-backend backend extend)) (grad nil) (thread-data thread-data) (destructive? t) (is-sysconst? t) (path-through-node? path-through-node?) (is-mat (typep value (quote mat))) (grad-tmp (make-grad-tmp)))</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Predicate:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">waffetensor-p</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Copier:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">copy-waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Print Function:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(lambda (tensor stream depth) (declare (ignore depth)) (format stream (render-tensor tensor)))</code></td></tr></table></div><div class="codex-docstring"><p>An structure of Waffe's Tensor.
This structure have:
</p><ol><li>data (type of WaffeTensorContentType)</li><li>the computation node for backprops, and grads</li><li>backend informations and parameters for optimizing.</li></ol><p>There's three ways to make it.
</p><dl><dt>(const value)</dt><dd>Constant tensor, grad won't be created.</dd><dt>(tensor value)</dt><dd>Parameter tensor, grad will be created.</dd><dt>(sysconst value)</dt><dd>Constant tensor where tensor sometime cached. Users don't have to use this.</dd></dl><p>Value is following:
</p><ol><li>simple-array</li><li>mgl-mat:mat (recommended)</li><li>fixnum</li><li>float</li><li>null</li><li>cons</li><li>function (for lazy evaluation)</li><li>ratio (when make, coerced to float)</li></ol><p>This structure is printable and printed nicely.</p></div><ul class="codex-slot-list"><li class="codex-slot codex-structure-slot"><code class="codex-name">data</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensortypes</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-data</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">grad-tmp</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::grad-tmp</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-grad-tmp</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(cl-waffe::make-grad-tmp)</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">backward</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-backward</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">backend</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">keyword</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-backend</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:mgl</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">grad</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensortypes</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-grad</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">variables</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">list</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-variables</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">state</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-state</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-mat</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-mat</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-param?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-param?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-ancestor-param</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-ancestor-param</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-next-destruct?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-is-next-destruct?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">destructive?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-destructive?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">thread-data</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or cl-waffe::waffenodethread null)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-thread-data</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-sysconst?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-sysconst?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">path-through-node?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-path-through-node?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">key</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or null cons)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-key</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">idx</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or null symbol)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-idx</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-data-destructed?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-is-data-destructed?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li></ul></div>
</p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">backward</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Compute back propagation by traversing the Tensor's computation node.</p><p>The parameters of the model defined by (tensor) or to which (Parameter tensor) is applied, store the gradient in grad slot.</p><p>Note that: tensor must be the shape of `(1) or single value. Otherwise an error occurs.</p><p>In the process calculating backward, new backwards won't be created. (*no-grad* automatically becomes t)</p><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>NIL</dd></dl></div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*no-grad*</code><div class="codex-docstring">When t, some node will be ignored. see references below for details. default: nil</div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-no-grad</code><code class="codex-lambda-list">(&amp;body body &amp;aux (no-grad-first (gensym)))</code><div class="codex-docstring"><p>This macro is like with-predict-mode</p><p>When you predicting your models, copying values for backward is waste.</p><p>In this macro, *no-grad* become t, and won't make computation nodes.</p><p>macro (save-for-backward) is ignored and they will be faster.</p></div></div>
</p><p>
</p><h2 id="forward-nodes">Forward Nodes</h2>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">call</code><code class="codex-lambda-list">(model &amp;rest args)</code><div class="codex-docstring"><p>Calling Forward Step defined by defmodel, defnode, defoptimizer.</p><p>And building computation node as long as *no-grad* is nil.</p><dl><dt>model</dt><dd>Your initialized model/node/optimizer objects</dd><dt>args</dt><dd>The args :forward needs</dd></dl><p>Output: =&gt; <code class="codex-param">tensor</code> produced by :forward</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-calling-layers</code><code class="codex-lambda-list">(input &amp;rest layers)</code><div class="codex-docstring"><p>This macro allows to sequentially call layers.</p><p>the argument <code class="codex-param">input</code> must be a tensor.</p><p>Refering each layers from (self) macro, destructively modifying x with the returned value.</p><pre><code class="lisp">(defmodel MLP (activation)
   :parameters ((layer1   (denselayer (* 28 28) 512 T activation))
   	        (layer2   (denselayer 512 256 T activation))
	        (layer3   (linearlayer 256 10 T)))
   :forward ((x)
	     (with-calling-layers x
	       (layer1 x)
 	       (layer2 x)
               (layer3 x))))
</code></pre><p>For the different arguments.</p><pre><code class="lisp">(with-calling-layers x
     (layer1 x 1 1)
     (layer2 1 x 2)
     (layer3 x y))
</code></pre><p>Output: An last value of layers.</p></div></div>

<p>
</p><h2 id="exported-parameters">Exported Parameters</h2><p><p>
<div class="codex-doc-node codex-variable"><code class="codex-name">*default-backend*</code><div class="codex-docstring">Default backend cl-waffe uses. Default: :mgl</div></div></p><p>Configs when printing tensor.<div class="codex-doc-node codex-variable"><code class="codex-name">*print-char-max-len*</code><div class="codex-docstring">When printing tensor, the character displayed following this param.
(e.g. When 5, in your terminal, 1.12345d0 =&gt; 1.1234...)
Default: 5</div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*print-arr-max-size*</code><div class="codex-docstring">When printing tensor, the tensor displayed following this param.
(e.g. When 5, in your terminal, (1 2 3 4 5 6 7 8 9 10) =&gt; (1 2 3 ... 4 5 6))
Default: 6</div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*print-mat-max-size*</code><div class="codex-docstring">When printing tensor, the tensor displayed following this param.
(e.g. When 3, in your terminal, ((1)(2)(3)(4)) =&gt; ((1)(2) ... (4)))</div></div>
</p></p><h2 id="types">Types</h2><p>
<div class="codex-doc-node codex-type"><code class="codex-name">waffetensorcontenttype</code><code class="codex-type-def">nil</code><div class="codex-docstring"><p>An type of data that allowed to make tensors with (const ~) or (tensor ~).</p><p>cl-waffe automatically coerce them to arbitary types</p><p>`(or mgl-mat:mat
     simple-array
     waffesupporteddatatype)</p></div></div>
<div class="codex-doc-node codex-type"><code class="codex-name">waffesupporteddatatype</code><code class="codex-type-def">nil</code><div class="codex-docstring"><p>An type of waffe-tensor's content type,</p><p>`(or fixnum float null cons function ratio)</p></div></div>

</p><h2 id="accessor">Accessor</h2><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">data</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Access tensor's data. This won't be copied.</p><p>When tensor's data is lazy evaluted, this function behave following:
</p><ol><li>When tensor is transposed and lazy evaluted, directly returns function object for speed.</li><li> When tensor is cached and lazy evaluted, returns mat object.</li></ol><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>mgl-mat:mat, or waffetensorcontentdata</dd></dl><p>Note: this function is setfable and inlined</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">grad</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Accessing tensor's grad.</p><p>When tensor's grad is nil, an error occurs</p><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>An tensor's grad which is the type of mgl-mat:mat or waffetensorcontettype</dd></dl><p>Note: grad is <b>not</b> setfable</p></div></div>
</p><p>
</p><p>
</p><h1 id="initialize-constants">Initialize Constants</h1><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!zeros</code><code class="codex-lambda-list">(shape)</code><div class="codex-docstring"><p>Initializing constant tensor with given shape, where initial elements are zero.</p><p>Input: shape (cons)</p><p>Output: Tensor (which is constant)</p><p>Example:
</p><pre><code class="lisp">(!zeros `(10 10)) =&gt; #Const(((0.0 0.0 ~ 0.0 0.0)        
                 ...
       (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!ones</code><code class="codex-lambda-list">(shape)</code><div class="codex-docstring">The same as !zeros but initial element is one</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!fill</code><code class="codex-lambda-list">(shape element)</code><div class="codex-docstring">The same as !zeros, !ones but initial element is given element
Input: element ... fixnum or single-float</div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">!arange</code><code class="codex-lambda-list">(&amp;rest args)</code><div class="codex-docstring">arange can be called with a varying number of positional arguments:</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!random</code><code class="codex-lambda-list">(dims limit)</code><div class="codex-docstring"><p>Initialize an tensor of dims (cons)</p><p>!random can be called with a varying number of type of arguments:</p><p>When limit=fixnum, init with 0~fixnum</p><p>When limit=single-float, init with 0~single-float</p><p>When limit=(cons fixnum1 fixnum2), init with fixnum1~fixnum2, where each element is fixnum</p><p>When limit=(cons single-float1 single-float2), init with single-float1~single-float2, where each element is single-float</p><p>Return: WaffeTensor
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!random-with</code><code class="codex-lambda-list">(dims f)</code><div class="codex-docstring"><p>Initialize the tensor of dims.</p><p>f is function and each element is initialized with f's value.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!normal</code><code class="codex-lambda-list">(dims &amp;optional (mean 2.0) (var 1.0))</code><div class="codex-docstring">Init with normal.</div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">!randn</code><code class="codex-lambda-list">(dims)</code><div class="codex-docstring">Init with normal where mean=0.0, var=1.0</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!beta</code><code class="codex-lambda-list">(dims a b)</code><div class="codex-docstring">TODO</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!gamma</code><code class="codex-lambda-list">(dims scale)</code><div class="codex-docstring">TODO</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!chisquare</code><code class="codex-lambda-list">(dims df)</code><div class="codex-docstring">TODO</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!bernoulli</code><code class="codex-lambda-list">(dims rate)</code><div class="codex-docstring"><p>Init a tensor of dims with bernoulli</p><p>rate is single-float, and [0 1]</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!zeros-like</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring">Return a const where the shape is the same as tensor but elements are zero.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!ones-like</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring">Return a const where the shape is the same as tensor but elements are one.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!full-like</code><code class="codex-lambda-list">nil</code><div class="codex-docstring">fulls like(todo)</div></div>
</p><h1 id="cut-and-displace-tensor">Cut and Displace Tensor</h1>
<p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!set-batch</code><code class="codex-lambda-list">(dataset start-row-index batch-size)</code><div class="codex-docstring"><p>Set batch where dataset is a 2d mat</p><p>Note: dataset's shape must be divided by batch-size (Todo Fix)</p><p>Internally, this function just modifying dataset's displacement.</p><p>So it's very fast.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!reset-batch</code><code class="codex-lambda-list">(dataset)</code><div class="codex-docstring">Reset batch of dataset (i.e.: reset dataset's displacement)</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!aref</code><code class="codex-lambda-list">(tensor &amp;rest dims)</code><div class="codex-docstring"><p>Very fast aref.</p><p>This function is setfable.</p><p>Cuts the area specified by dims from Tensor and generates a new Const.</p><p>This function creates computation node.</p><p>dims are following:
</p><ol><li>fixnum</li><li>t ... which means 0 ... maxlen</li><li>Cons (e.g. '(1 3) reads 1&lt;=x&lt;3)
</li></ol><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10)))

;=&gt; #Const(((0.280... 1.941... ~ 0.723... -0.47...)        
;                   ...
;          (-1.01... 0.232... ~ -1.16... 0.405...)) :mgl t :shape (10 10))

(!aref a '(0 3) t)
(!aref a t '(0 3))
(!aref a 1 1)
(setq a (setf (!aref a '(0 3) '(0 3))(!zeros '(3 3)))) ; to update nodes

</code></pre><p>Todo: Bugfix</p></div></div>
</p>
<h1 id="shaping">Shaping</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!shape</code><code class="codex-lambda-list">(tensor &amp;optional (nth nil))</code><div class="codex-docstring"><p>Return the shape of tensor</p><p>Tensor is WaffeTensor.</p><p>Output is Cons or fixnum</p><p>When nth is not nil, return (nth nth (!shape tensor))</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!dims</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Return total length of the given tensor's dims</p><p>Example:
</p><pre><code class="lisp">(!dims (!zeros '(10 10 10))) ; =&gt; 3
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!size</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Return total size of tensor</p><p>Example:</p><pre><code class="lisp">(!dims (!zeros '(10 10 10))) ; =&gt; 1000
</code></pre></div></div>

<h1 id="operations">Operations</h1><p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!add</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Add x y, creating new sysconst and nodes.</p><p>As a modify: (!modify x :+= y)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sub</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Subtract x by y, creating new sysconst and nodes.</p><p>As a modify: (!modify x :-= y)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!mul</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Mul x y, creating new sysconst and nodes</p><p>As a modify: (!modify x :*= y)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!div</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Div x y, creating new sysconst and nodes.</p><p>As a modify: (!modify x :/= y)</p></div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!matmul</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Matmul</p><p>Todo: write docs and behaviour</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!dot</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring">Dot product of x and y, creating new sysconst and nodes</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!pow</code><code class="codex-lambda-list">(x n)</code><div class="codex-docstring"><p>Pow x n, creating new sysconst and nodes.</p><p>As a modify: (!modify x :^= y)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sqrt</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Sqrt x, creating new sysconst and nodes.</p><p>As a modify: (!modify x :sqrt y)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!log</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Log x, creating new sysconst and nodes.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!exp</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Exp x, creating new sysconst and nodes.</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sum</code><code class="codex-lambda-list">(x &amp;optional (axis nil) (keepdims nil))</code><div class="codex-docstring"><p>Sum up X where x is a tensor (the size of dims doesn't matter.)</p><p>Todo: Write docs and examples</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!mean</code><code class="codex-lambda-list">(x &amp;optional (axis nil) (keepdims nil))</code><div class="codex-docstring">Mean of tensor, todo: write docs and examples</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!modify</code><code class="codex-lambda-list">(target instruction &amp;rest args)</code><div class="codex-docstring"><p>The function that allows destructively operations, always changing the target.</p><p>If you need mgl-mat-wise operations for speed and low memory, this is useful.</p><p>Directly Calling Mgl-mat Operations.</p><p>Please remain that it won't make backwards because of speed problems.(Todo: Fix)</p><p>Always return `target` tensor. target always changed, and args sometimes changed</p><p>Instruction is a symbol where described with modify:</p><p>Todo: Write more details.</p><p>Example:</p><pre><code class="lisp">(!modify x :+= y)
</code></pre></div></div></p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!squeeze</code><code class="codex-lambda-list">(x &amp;optional (dim nil))</code><div class="codex-docstring">Squeeze todo: write docs</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!unsqueeze</code><code class="codex-lambda-list">(x &amp;optional (dim 0))</code><div class="codex-docstring">Unsqueeze Todo: write docs</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!repeats</code><code class="codex-lambda-list">(x axis repeats)</code><div class="codex-docstring">Repeat Todo: Write docs and example</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!reshape</code><code class="codex-lambda-list">(x dim)</code><div class="codex-docstring">(!reshape x dim) ,if dim has t, t is automatically predicted.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!transpose</code><code class="codex-lambda-list">(x &amp;optional result)</code><div class="codex-docstring"><p>Transpose</p><p>Note: the result of !transpose is lazy evaluated for speed.(Todo: Write details)</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!aref</code><code class="codex-lambda-list">(tensor &amp;rest dims)</code><div class="codex-docstring"><p>Very fast aref.</p><p>This function is setfable.</p><p>Cuts the area specified by dims from Tensor and generates a new Const.</p><p>This function creates computation node.</p><p>dims are following:
</p><ol><li>fixnum</li><li>t ... which means 0 ... maxlen</li><li>Cons (e.g. '(1 3) reads 1&lt;=x&lt;3)
</li></ol><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10)))

;=&gt; #Const(((0.280... 1.941... ~ 0.723... -0.47...)        
;                   ...
;          (-1.01... 0.232... ~ -1.16... 0.405...)) :mgl t :shape (10 10))

(!aref a '(0 3) t)
(!aref a t '(0 3))
(!aref a 1 1)
(setq a (setf (!aref a '(0 3) '(0 3))(!zeros '(3 3)))) ; to update nodes

</code></pre><p>Todo: Bugfix</p></div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!modify</code><code class="codex-lambda-list">(target instruction &amp;rest args)</code><div class="codex-docstring"><p>The function that allows destructively operations, always changing the target.</p><p>If you need mgl-mat-wise operations for speed and low memory, this is useful.</p><p>Directly Calling Mgl-mat Operations.</p><p>Please remain that it won't make backwards because of speed problems.(Todo: Fix)</p><p>Always return `target` tensor. target always changed, and args sometimes changed</p><p>Instruction is a symbol where described with modify:</p><p>Todo: Write more details.</p><p>Example:</p><pre><code class="lisp">(!modify x :+= y)
</code></pre></div></div>
</p></p><h1 id="math-functions">Math Functions</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!tanh</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Applying tanh to x, return a new sysconst with making nodes.</div></div>

<h1 id="activations">Activations</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!relu</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Applying relu to x, return a new sysconst with making nodes.</p><p>Relu(x) = { 0 (x &lt; 0), x (x &gt; 0) }</p><p>Input: x where x is waffe supported data type.</p><p>Output: Tensor</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sigmoid</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Applyong sigmoid to x, return a new sysconst with making nodes.</p><p>Input: x where x is waffe supported data type.</p><p>Output: Tensor</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!tanh</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Applying tanh to x, return a new sysconst with making nodes.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!softmax</code><code class="codex-lambda-list">(x &amp;key (avoid-overflow t))</code><div class="codex-docstring"><p>Applying softmax.</p><p>!softmax has three behaivour depending on the number of dimensions.</p></div></div>

<h1 id="utils-for-defnode">Utils for defnode</h1>
These features for advanced.
<div class="codex-error codex-no-node">No node with name <code>warranty</code>.</div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-kernel-case</code><code class="codex-lambda-list">(target var &amp;key (mgl nil) (mgl-cuda nil) (copy t) &amp;aux (out (gensym)))</code><div class="codex-docstring"><p>Reading the target's device, this macro invokes property codes described in :mgl, :mgl-cuda etc...</p><p>   Dynamically defining and caching cpu and cuda kernel.</p><p>   Every time reaches this macro, cl-waffe caches the target (i.e. the target is allowed to be destructed).</p><p>   This macro won't create computation nodes.</p><p>   The available slot is in *kernels*</p><p>   When :mgl-cuda is nil, automatically calls :mgl</p><p>   This macro returns the last value of called slots.</p><p>   The last value of :mgl, :mgl-cuda and so on, must be type of list (cons), or mgl-mat:mat, waffetensorcontenttype.</p><p>   Note: the target's thread-data must be already created. (i.e. By the time tensors reach this macro, at least once they needed to be pathed through Trainer or Model.)
   So, use this macro when you defining :forward and :backward in defnode macro because in defnode, backprop is disabled and computation nodes isn't always required.</p><p>Inputs
</p><dl><dt>target</dt><dd>an target tensor.</dd><dt>var</dt><dd>where an copied tensor of target will be assigned.</dd><dt>:mgl</dt><dd>mgl-mat, when using cpu.</dd><dt>:mgl-mat</dt><dd>mgl-mat, when using cuda.</dd></dl><p>Return: An tensor (where tensor is made by sysconst)</p><p>Example:</p><pre><code class="lisp">(with-kernel-case x o
     :mgl (progn
            (axpy! 1.0 a o)) ; axpy! = !add
     :mgl-cuda nil) =&gt; #Const(((0.0 1.0 ~ 2.0 3.0)        
                 ...
      (0.0 4.0 ~ 5.0 6.0)) :mgl t :shape (10 10))

 ; This is useful when defining :backward
 (with-kernel-case x o
     :mgl (progn
            (list 1 1)))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">call-and-dispatch-kernel</code><code class="codex-lambda-list">(kernel-function &amp;rest args)</code><div class="codex-docstring"><p>Invoke kernel and run kernel-function. return new sysconst</p><p>Todo:More Details</p></div></div>

<h1 id="train-and-valid">Train And Valid</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">train</code><code class="codex-lambda-list">(trainer dataset &amp;key (valid-dataset nil) (valid-each 100) (enable-animation t) (epoch 1) (batch-size 1) (max-iterate nil) (verbose t) (stream t) (progress-bar-freq 1) (save-model-path nil) (width 45) (random nil) (height 10) (print-each 10))</code><div class="codex-docstring"><p>Trainining given trainer. If any, valid <code class="codex-param">valid-dataset</code></p><dl><dt>trainer</dt><dd>Trainer you defined by deftrainer</dd><dt>dataset</dt><dd>Dataset you defined by defdataset</dd><dt>valid-dataset</dt><dd>If valid-dataset=your dataset, use this to valid. If nil, ignored</dd><dt>enable-animation</dt><dd>Ignored</dd><dt>epoch</dt><dd>Iterate training by epoch, default=1</dd><dt>batch-size</dt><dd>Do batch training. default=1</dd><dt>verbose</dt><dd>if t, put log to stream</dd></dl><p>This function is temporary and other arguments are ignored.</p><p>And this function has a lot of todo.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">valid</code><code class="codex-lambda-list">(trainer dataset batch-size)</code><div class="codex-docstring">Valid trainer</div></div>

<h1 id="datasets">Datasets</h1>

<div class="codex-doc-node codex-record codex-structure"><code class="codex-name">waffedataset</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Constructor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(waffedataset train valid &amp;key (batch-size 1) &amp;aux (train train) (valid valid) (batch-size batch-size))</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Predicate:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">waffedataset-p</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Copier:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">copy-waffedataset</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Print Function:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">print-dataset</code></td></tr></table></div><div class="codex-docstring"><h2 id="1-cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</h2>
<b>This structure is an cl-waffe object</b> 
<dl><dt>Overview</dt><dd>The standard dataset for 2d training data.</dd><dt>How to Initialize</dt><dd><pre><code class="lisp">(WaffeDataSet train valid &amp;key (batch-size 1)) =&gt; [DATASET: WaffeDataSet]
</code></pre>
</dd><dt>get-dataset</dt><dd><pre><code class="lisp">(get-dataset WaffeDataSet index) ; =&gt; Next Batch
</code></pre>
</dd><dt>get-dataset-length</dt><dd><pre><code class="lisp">(get-dataset-length WaffeDataSet) ; =&gt; Total length of WaffeDataSet
</code></pre>
</dd><dt>Object's slots</dt><dd></dd></dl>
</div><ul class="codex-slot-list"><li class="codex-slot codex-structure-slot"><code class="codex-name">train</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-train</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:train</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">valid</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-valid</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::valid</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">batch-size</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">fixnum</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-batch-size</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::batch-size</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">length</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-length</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">dataset-next</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-dataset-next</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr></table></div></li></ul></div>


      </div>
    </main>
  </article>
  <footer>
    <div class="info">
      Created with <a href="https://github.com/CommonDoc/codex">Codex</a>.
    </div>
  </footer>
  <script>
   HighlightLisp.highlight_auto();
  </script>

  </body>
</html>
