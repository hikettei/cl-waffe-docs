<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
  cl-waffe &ndash; cl-waffe
</title>
    <link rel="stylesheet" href="static/style.css"/>
    
  <link rel="stylesheet" href="static/highlight.css"/>
  <script src="static/highlight.js"></script>
  <style>
   /* Highlight the current top-level TOC item, and hide the TOC of all other items */

   .toc a[data-node="cl-waffe"] {
       /*color: #AD3108;*/
   }

   .toc ol {
       display: none;
   }

   .toc li a[data-node="cl-waffe"] {
       font-weight: bold;
   }

   .toc li a[data-node="cl-waffe"] + ol {
       display: block;
   }

   .toc li a[data-node="cl-waffe"] + ol li {
       margin-left: 10px;
   }
  </style>

  </head>
  <body>
    
  <h1 class="doc-title">cl-waffe</h1>
  <article id="article" data-section="cl-waffe">
    <aside>
      <ol class="toc"><li><a href="overview.html" data-node="overview">Overview</a><ol><li><a href="overview.html#welcome-to-cl-waffe!" data-node="welcome-to-cl-waffe!">Welcome to cl-waffe!</a></li><li><a href="overview.html#todo-list-and-problems" data-node="todo-list-and-problems">Todo List And Problems</a></li><li><a href="overview.html#pull-requests" data-node="pull-requests">Pull Requests</a></li><li><a href="overview.html#contacts" data-node="contacts">Contacts</a></li><li><a href="overview.html#lla-setting" data-node="lla-setting">LLA Setting</a></li><li><a href="overview.html#when-memory-exhausted" data-node="when-memory-exhausted">When Memory Exhausted</a></li></ol></li><li><a href="basics.html" data-node="basics">Basics</a><ol><li><a href="basics.html#first" data-node="first">First</a></li><li><a href="basics.html#define-your-model" data-node="define-your-model">Define Your Model</a></li><li><a href="basics.html#define-your-dataset" data-node="define-your-dataset">Define Your Dataset</a><ol><li><a href="cl-waffe's-dataset--waffedataset.html" data-node="cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</a></li></ol></li><li><a href="basics.html#train-your-model" data-node="train-your-model">Train Your Model</a></li></ol></li><li><a href="advanced.html" data-node="advanced">Advanced</a><ol><li><a href="advanced.html#exported" data-node="exported">Exported</a></li></ol></li><li><a href="basic-tensor-operations.html" data-node="basic-tensor-operations">Basic Tensor Operations</a><ol><li><a href="basic-tensor-operations.html#0-basic-tensor-operations" data-node="0-basic-tensor-operations">Basic Tensor Operations</a></li></ol></li><li><a href="cl-waffe.html" data-node="cl-waffe">cl-waffe</a><ol><li><a href="cl-waffe.html#package--cl-waffe" data-node="package--cl-waffe">Package: cl-waffe</a></li><li><a href="cl-waffe.html#sections" data-node="sections">Sections</a></li><li><a href="cl-waffe.html#defining-objects" data-node="defining-objects">Defining objects</a></li><li><a href="cl-waffe.html#documents-in-cl-waffe's-object" data-node="documents-in-cl-waffe's-object">Documents in cl-waffe's object</a></li><li><a href="cl-waffe.html#tensor" data-node="tensor">Tensor</a><ol><li><a href="cl-waffe.html#basic-of-tensor-and-backward" data-node="basic-of-tensor-and-backward">Basic of Tensor and backward</a><ol><li><a href="cl-waffe.html#initialize-tensor" data-node="initialize-tensor">Initialize Tensor</a><ol><li><a href="cl-waffe.html#parameters" data-node="parameters">Parameters</a></li><li><a href="cl-waffe.html#constants" data-node="constants">Constants</a></li><li><a href="cl-waffe.html#tensor-vs-const" data-node="tensor-vs-const">Tensor vs Const</a></li></ol></li></ol></li><li><a href="cl-waffe.html#forward-nodes" data-node="forward-nodes">Forward Nodes</a></li><li><a href="cl-waffe.html#exported-parameters" data-node="exported-parameters">Exported Parameters</a></li><li><a href="cl-waffe.html#types" data-node="types">Types</a></li><li><a href="cl-waffe.html#accessor" data-node="accessor">Accessor</a></li></ol></li><li><a href="cl-waffe.html#initialize-constants" data-node="initialize-constants">Initialize Constants</a><ol><li><a href="(-!arange-stop-).html" data-node="(-!arange-stop-)">(!arange stop)</a><a href="(-!arange-start-stop-).html" data-node="(-!arange-start-stop-)">(!arange start stop)</a><a href="(-!arange-start-stop-step-).html" data-node="(-!arange-start-stop-step-)">(!arange start stop step)</a></li><li><a href="when-limit=fixnum.html" data-node="when-limit=fixnum">When limit=fixnum</a><a href="when-limit=single-float.html" data-node="when-limit=single-float">When limit=single-float</a><a href="when-limit=-(-cons-single-float1-single-float2-).html" data-node="when-limit=-(-cons-single-float1-single-float2-)">When limit=(cons single-float1 single-float2)</a></li></ol></li><li><a href="cl-waffe.html#cut-and-displace-tensor" data-node="cut-and-displace-tensor">Cut and Displace Tensor</a></li><li><a href="cl-waffe.html#shaping" data-node="shaping">Shaping</a></li><li><a href="cl-waffe.html#operations" data-node="operations">Operations</a><ol><li><a href="examples.html" data-node="examples">Examples</a><a href="1-examples.html" data-node="1-examples">Examples</a><a href="2-examples.html" data-node="2-examples">Examples</a><a href="3-examples.html" data-node="3-examples">Examples</a></li><li><a href="example.html" data-node="example">Example</a></li><li><a href="4-example.html" data-node="4-example">Example</a><a href="5-example.html" data-node="5-example">Example</a><a href="6-example.html" data-node="6-example">Example</a><a href="7-example.html" data-node="7-example">Example</a></li><li><a href="arguments.html" data-node="arguments">arguments</a><a href="8-example.html" data-node="8-example">Example</a><a href="9-example.html" data-node="9-example">Example</a></li><li><a href="10-example.html" data-node="10-example">Example</a><a href="11-example.html" data-node="11-example">Example</a><a href="12-example.html" data-node="12-example">Example</a><a href="13-example.html" data-node="13-example">Example</a><a href="14-example.html" data-node="14-example">Example</a></li></ol></li><li><a href="cl-waffe.html#math-functions" data-node="math-functions">Math Functions</a></li><li><a href="cl-waffe.html#activations" data-node="activations">Activations</a></li><li><a href="cl-waffe.html#utils-for-defnode" data-node="utils-for-defnode">Utils for defnode</a></li><li><a href="cl-waffe.html#train-and-valid" data-node="train-and-valid">Train And Valid</a></li><li><a href="cl-waffe.html#datasets" data-node="datasets">Datasets</a><ol><li><a href="15-cl-waffe's-dataset--waffedataset.html" data-node="15-cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</a></li></ol></li></ol></li><li><a href="cl-waffe.nn.html" data-node="cl-waffe.nn">cl-waffe.nn</a><ol><li><a href="models.html" data-node="models">Models</a><ol><li><a href="cl-waffe's-model--embedding.html" data-node="cl-waffe's-model--embedding">cl-waffe's Model: Embedding</a></li><li><a href="16-cl-waffe's-model--embedding.html" data-node="16-cl-waffe's-model--embedding">cl-waffe's Model: Embedding</a></li><li><a href="cl-waffe's-model--rnn.html" data-node="cl-waffe's-model--rnn">cl-waffe's Model: RNN</a></li></ol></li><li><a href="aggregations.html" data-node="aggregations">aggregations</a><ol><li><a href="cl-waffe's-node--dropout.html" data-node="cl-waffe's-node--dropout">cl-waffe's Node: Dropout</a></li><li><a href="cl-waffe's-model--batchnorm2d.html" data-node="cl-waffe's-model--batchnorm2d">cl-waffe's Model: BatchNorm2d</a></li></ol></li><li><a href="losses.html" data-node="losses">losses</a></li></ol></li><li><a href="cl-waffe.optimizers.html" data-node="cl-waffe.optimizers">cl-waffe.optimizers</a><ol><li><a href="sgd.html" data-node="sgd">SGD</a><ol><li><a href="cl-waffe's-optimizer--sgd.html" data-node="cl-waffe's-optimizer--sgd">cl-waffe's Optimizer: SGD</a></li></ol></li><li><a href="momentum.html" data-node="momentum">Momentum</a><ol><li><a href="cl-waffe's-optimizer--momentum.html" data-node="cl-waffe's-optimizer--momentum">cl-waffe's Optimizer: Momentum</a></li></ol></li><li><a href="adagrad.html" data-node="adagrad">AdaGrad</a><ol><li><a href="cl-waffe's-optimizer--adagrad.html" data-node="cl-waffe's-optimizer--adagrad">cl-waffe's Optimizer: AdaGrad</a></li></ol></li><li><a href="rmsprop.html" data-node="rmsprop">RMSProp</a><ol><li><a href="cl-waffe's-optimizer--rmsprop.html" data-node="cl-waffe's-optimizer--rmsprop">cl-waffe's Optimizer: RMSProp</a></li></ol></li><li><a href="adam.html" data-node="adam">Adam</a><ol><li><a href="cl-waffe's-optimizer--adam.html" data-node="cl-waffe's-optimizer--adam">cl-waffe's Optimizer: Adam</a></li></ol></li></ol></li><li><a href="cl-waffe.io.html" data-node="cl-waffe.io">cl-waffe.io</a><ol><li><a href="17-exported.html" data-node="17-exported">Exported</a></li></ol></li><li><a href="cl-waffe.caches.html" data-node="cl-waffe.caches">cl-waffe.caches</a><ol><li><a href="18-exported.html" data-node="18-exported">Exported</a></li></ol></li><li><a href="operators.html" data-node="operators">Operators</a><ol><li><a href="!zeros.html" data-node="!zeros">!zeros</a></li><li><a href="!ones.html" data-node="!ones">!ones</a></li><li><a href="!fill.html" data-node="!fill">!fill</a></li><li><a href="!arange.html" data-node="!arange">!arange</a><ol><li><a href="19-(-!arange-stop-).html" data-node="19-(-!arange-stop-)">(!arange stop)</a></li><li><a href="20-(-!arange-start-stop-).html" data-node="20-(-!arange-start-stop-)">(!arange start stop)</a></li><li><a href="21-(-!arange-start-stop-step-).html" data-node="21-(-!arange-start-stop-step-)">(!arange start stop step)</a></li></ol></li><li><a href="!random.html" data-node="!random">!random</a><ol><li><a href="22-when-limit=fixnum.html" data-node="22-when-limit=fixnum">When limit=fixnum</a></li><li><a href="23-when-limit=single-float.html" data-node="23-when-limit=single-float">When limit=single-float</a></li><li><a href="24-when-limit=-(-cons-single-float1-single-float2-).html" data-node="24-when-limit=-(-cons-single-float1-single-float2-)">When limit=(cons single-float1 single-float2)</a></li></ol></li><li><a href="!random-with.html" data-node="!random-with">!random-with</a></li><li><a href="25-!random-with.html" data-node="25-!random-with">!random-with</a></li><li><a href="!normal.html" data-node="!normal">!normal</a></li><li><a href="!randn.html" data-node="!randn">!randn</a></li><li><a href="!beta.html" data-node="!beta">!beta</a></li><li><a href="!gamma.html" data-node="!gamma">!gamma</a></li><li><a href="!chisquare.html" data-node="!chisquare">!chisquare</a></li><li><a href="!bernoulli.html" data-node="!bernoulli">!bernoulli</a></li><li><a href="!binomial.html" data-node="!binomial">!binomial</a></li><li><a href="!shape.html" data-node="!shape">!shape</a></li><li><a href="!dims.html" data-node="!dims">!dims</a></li><li><a href="!size.html" data-node="!size">!size</a></li><li><a href="!zeros-like.html" data-node="!zeros-like">!zeros-like</a></li><li><a href="!ones-like.html" data-node="!ones-like">!ones-like</a></li><li><a href="!full-like.html" data-node="!full-like">!full-like</a></li><li><a href="!add.html" data-node="!add">!add</a><ol><li><a href="26-examples.html" data-node="26-examples">Examples</a></li></ol></li><li><a href="!sub.html" data-node="!sub">!sub</a><ol><li><a href="27-examples.html" data-node="27-examples">Examples</a></li></ol></li><li><a href="!mul.html" data-node="!mul">!mul</a><ol><li><a href="28-examples.html" data-node="28-examples">Examples</a></li></ol></li><li><a href="!div.html" data-node="!div">!div</a><ol><li><a href="29-examples.html" data-node="29-examples">Examples</a></li></ol></li><li><a href="!dot.html" data-node="!dot">!dot</a><ol><li><a href="30-example.html" data-node="30-example">Example</a></li></ol></li><li><a href="!sum.html" data-node="!sum">!sum</a><ol><li><a href="31-arguments.html" data-node="31-arguments">arguments</a></li><li><a href="32-example.html" data-node="32-example">Example</a></li></ol></li><li><a href="!mean.html" data-node="!mean">!mean</a><ol><li><a href="33-example.html" data-node="33-example">Example</a></li></ol></li><li><a href="!exp.html" data-node="!exp">!exp</a><ol><li><a href="34-example.html" data-node="34-example">Example</a></li></ol></li><li><a href="!pow.html" data-node="!pow">!pow</a><ol><li><a href="35-example.html" data-node="35-example">Example</a></li></ol></li><li><a href="!sqrt.html" data-node="!sqrt">!sqrt</a><ol><li><a href="36-example.html" data-node="36-example">Example</a></li></ol></li><li><a href="!log.html" data-node="!log">!log</a><ol><li><a href="37-example.html" data-node="37-example">Example</a></li></ol></li><li><a href="!sin.html" data-node="!sin">!sin</a><ol><li><a href="38-example.html" data-node="38-example">Example</a></li></ol></li><li><a href="!cos.html" data-node="!cos">!cos</a><ol><li><a href="39-example.html" data-node="39-example">Example</a></li></ol></li><li><a href="!tan.html" data-node="!tan">!tan</a><ol><li><a href="40-example.html" data-node="40-example">Example</a></li></ol></li><li><a href="!asin.html" data-node="!asin">!asin</a></li><li><a href="!acos.html" data-node="!acos">!acos</a></li><li><a href="!atan.html" data-node="!atan">!atan</a></li><li><a href="!sinh.html" data-node="!sinh">!sinh</a><ol><li><a href="41-example.html" data-node="41-example">Example</a></li></ol></li><li><a href="!cosh.html" data-node="!cosh">!cosh</a><ol><li><a href="42-example.html" data-node="42-example">Example</a></li></ol></li><li><a href="!tanh.html" data-node="!tanh">!tanh</a></li><li><a href="!asinh.html" data-node="!asinh">!asinh</a></li><li><a href="!acosh.html" data-node="!acosh">!acosh</a></li><li><a href="!atanh.html" data-node="!atanh">!atanh</a></li><li><a href="!matmul.html" data-node="!matmul">!matmul</a></li><li><a href="!unsqueeze.html" data-node="!unsqueeze">!unsqueeze</a><ol><li><a href="43-example.html" data-node="43-example">Example</a></li></ol></li><li><a href="!squeeze.html" data-node="!squeeze">!squeeze</a><ol><li><a href="44-example.html" data-node="44-example">Example</a></li></ol></li><li><a href="!transpose.html" data-node="!transpose">!transpose</a><ol><li><a href="45-example.html" data-node="45-example">Example</a></li></ol></li><li><a href="!repeats.html" data-node="!repeats">!repeats</a><ol><li><a href="46-example.html" data-node="46-example">Example</a></li></ol></li><li><a href="!reshape.html" data-node="!reshape">!reshape</a><ol><li><a href="47-example.html" data-node="47-example">Example</a></li></ol></li><li><a href="!abs.html" data-node="!abs">!abs</a></li><li><a href="!where.html" data-node="!where">!where</a></li><li><a href="!index.html" data-node="!index">!index</a></li><li><a href="!argmax.html" data-node="!argmax">!argmax</a><ol><li><a href="48-example.html" data-node="48-example">Example</a></li></ol></li><li><a href="!argmin.html" data-node="!argmin">!argmin</a><ol><li><a href="49-example.html" data-node="49-example">Example</a></li></ol></li><li><a href="!<=.html" data-node="!<=">!&lt;=</a></li><li><a href="!>=.html" data-node="!>=">!&gt;=</a></li><li><a href="!einsum.html" data-node="!einsum">!einsum</a></li><li><a href="!ravel.html" data-node="!ravel">!ravel</a></li><li><a href="!flatten.html" data-node="!flatten">!flatten</a></li><li><a href="!aref.html" data-node="!aref">!aref</a></li><li><a href="!dotensors.html" data-node="!dotensors">!dotensors</a></li><li><a href="!set-batch.html" data-node="!set-batch">!set-batch</a></li><li><a href="!softmax.html" data-node="!softmax">!softmax</a></li><li><a href="!sigmoid.html" data-node="!sigmoid">!sigmoid</a></li><li><a href="!relu.html" data-node="!relu">!relu</a></li><li><a href="!gelu.html" data-node="!gelu">!gelu</a></li><li><a href="!leakey-relu.html" data-node="!leakey-relu">!leakey-relu</a></li><li><a href="!swish.html" data-node="!swish">!swish</a></li></ol></li><li><a href="nn.html" data-node="nn">NN</a><ol><li><a href="model-list.html" data-node="model-list">model-list</a><ol><li><a href="cl-waffe's-model--model-list.html" data-node="cl-waffe's-model--model-list">cl-waffe's Model: model-list</a></li></ol></li><li><a href="linearlayer.html" data-node="linearlayer">Linearlayer</a></li><li><a href="denselayer.html" data-node="denselayer">Denselayer</a></li><li><a href="dropout.html" data-node="dropout">Dropout</a><ol><li><a href="50-cl-waffe's-node--dropout.html" data-node="50-cl-waffe's-node--dropout">cl-waffe's Node: Dropout</a></li></ol></li><li><a href="batchnorm2d.html" data-node="batchnorm2d">BatchNorm2d</a><ol><li><a href="51-cl-waffe's-model--batchnorm2d.html" data-node="51-cl-waffe's-model--batchnorm2d">cl-waffe's Model: BatchNorm2d</a></li></ol></li><li><a href="layernorm.html" data-node="layernorm">LayerNorm</a></li><li><a href="embedding.html" data-node="embedding">Embedding</a><ol><li><a href="52-cl-waffe's-model--embedding.html" data-node="52-cl-waffe's-model--embedding">cl-waffe's Model: Embedding</a></li></ol></li><li><a href="rnn.html" data-node="rnn">RNN</a><ol><li><a href="53-cl-waffe's-model--rnn.html" data-node="53-cl-waffe's-model--rnn">cl-waffe's Model: RNN</a></li></ol></li><li><a href="lstm.html" data-node="lstm">LSTM</a></li><li><a href="gru.html" data-node="gru">GRU</a></li><li><a href="maxpooling.html" data-node="maxpooling">MaxPooling</a></li><li><a href="avgpooling.html" data-node="avgpooling">AvgPooling</a></li><li><a href="conv1d.html" data-node="conv1d">Conv1D</a></li><li><a href="conv2d.html" data-node="conv2d">Conv2D</a></li><li><a href="transformer.html" data-node="transformer">Transformer</a></li><li><a href="transformerencoderlayer.html" data-node="transformerencoderlayer">TransformerEncoderLayer</a></li><li><a href="transformerdecoderlayer.html" data-node="transformerdecoderlayer">TransformerDecoderLayer</a></li><li><a href="crossentropy.html" data-node="crossentropy">CrossEntropy</a></li><li><a href="softmaxcrossentropy.html" data-node="softmaxcrossentropy">SoftMaxCrossEntropy</a></li><li><a href="mse.html" data-node="mse">MSE</a></li><li><a href="l1norm.html" data-node="l1norm">L1Norm</a></li><li><a href="l2norm.html" data-node="l2norm">L2Norm</a></li><li><a href="binarycrossentropy.html" data-node="binarycrossentropy">BinaryCrossEntropy</a></li><li><a href="kldivloss.html" data-node="kldivloss">KLdivLoss</a></li><li><a href="cosinesimilarity.html" data-node="cosinesimilarity">CosineSimilarity</a></li></ol></li><li><a href="optimizers.html" data-node="optimizers">Optimizers</a><ol><li><a href="54-sgd.html" data-node="54-sgd">SGD</a><ol><li><a href="55-cl-waffe's-optimizer--sgd.html" data-node="55-cl-waffe's-optimizer--sgd">cl-waffe's Optimizer: SGD</a></li></ol></li><li><a href="56-momentum.html" data-node="56-momentum">Momentum</a><ol><li><a href="57-cl-waffe's-optimizer--momentum.html" data-node="57-cl-waffe's-optimizer--momentum">cl-waffe's Optimizer: Momentum</a></li></ol></li><li><a href="58-adagrad.html" data-node="58-adagrad">AdaGrad</a><ol><li><a href="59-cl-waffe's-optimizer--adagrad.html" data-node="59-cl-waffe's-optimizer--adagrad">cl-waffe's Optimizer: AdaGrad</a></li></ol></li><li><a href="60-rmsprop.html" data-node="60-rmsprop">RMSProp</a><ol><li><a href="61-cl-waffe's-optimizer--rmsprop.html" data-node="61-cl-waffe's-optimizer--rmsprop">cl-waffe's Optimizer: RMSProp</a></li></ol></li><li><a href="62-adam.html" data-node="62-adam">Adam</a><ol><li><a href="63-cl-waffe's-optimizer--adam.html" data-node="63-cl-waffe's-optimizer--adam">cl-waffe's Optimizer: Adam</a></li></ol></li><li><a href="adamw.html" data-node="adamw">AdamW</a></li><li><a href="radam.html" data-node="radam">RAdam</a></li></ol></li></ol>
    </aside>
    <main class="codex-section">
      <header>
        <h2 class="section-title">cl-waffe</h2>
      </header>
      <div class="content">
        <p>
</p><h1 id="package--cl-waffe">Package: cl-waffe</h1>
This package is under development and APIs can be changed without notice.
<h1 id="sections">Sections</h1>
Put table here
<h1 id="defining-objects">Defining objects</h1><p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defmodel</code><code class="codex-lambda-list">(name args &amp;key (parameters nil) forward (optimize nil) (document An model, defined by cl-waffe))</code><div class="codex-docstring"><p>This macro defines a cl-waffe model as <code class="codex-param">name</code>.</p><p>At the same time, a constructor <code class="codex-param">name</code> is defined and you can initialize your model like:</p><pre><code class="lisp">(cl-waffe.nn:LinearLayer 100 20) ; =&gt; [Model: Linearlayer]
</code></pre><p>
</p><dl><dt>name</dt><dd>Your model and constructor name</dd><dt>args</dt><dd>The arguments of a constructor</dd><dt>parameters</dt><dd><p>The parameters your model has.</p><p>Every time you initialize the model, the parameters are initialized.</p><p>Note that <code class="codex-param">defmodel</code> behaves like class.</p><p>The arguments are the same as <a href="http://l1sp.org/cl/defstruct"><code>defstruct</code></a></p><p>Format Example: ((param-name param-initial-value &amp;key (type your-type)))</p></dd><dt>optimize</dt><dd>when t, your forward slot is defined with (declare (optimize (speed 3)(space 0)(debug 0))). It helps faster training after you ensured debugged.</dd><dt>forward</dt><dd><p>Define here the forward propagation of your model.</p><p>When backward, <b>Automatic differentiation applies</b>.</p></dd></dl><p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defnode</code><code class="codex-lambda-list">(name args &amp;key parameters forward backward optimize (regard-as-node t) (document An node, defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining computation nodes.</p><p>defnode is useful when you want to define the derivative yourself.<b>Note that parameter tensors in :parameter won't updated by optimizers.</b></p><p>If you want to update params, define additional models.</p><dl><dt>regard-as-node</dt><dd>When the slot :regard-as-node is nil, an optimizer in cl-waffe.caches regards this as model (i.e. argument could be destructed.) Default is t.
</dd></dl><p>Note that:</p><ol><li>:backward must return list, where that length corresponds with the length of input's argument, otherwise an error occurs when backward.</li><li>In forward and backward, computation node isn't needed to be continuous.However, the last values of :forward and :backward step, must posses :thread-data, which can be obtained by (waffetensor-thread-data tensor)</li></ol><p>Example:</p><pre><code class="lisp">(defnode AddTensor nil
  :optimize t
  :parameters nil
  :forward  ((x y)
	     (with-searching-calc-node :add x y))
  :backward ((dy)(list dy dy)))

(call (AddTensor) tensor1 tensor2)
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defoptimizer</code><code class="codex-lambda-list">(name args &amp;key parameters update optimize (document An optimizer, defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining optimizers. Internally, This is paraphase of defmodel, which slot names are just different.</p><p>Note: by calling :backward slot, optimizers work as (zero-grad).</p><dl><dt>Name</dt><dd>The optimizer's structure and constructor will be defined based on name</dd><dt>Args</dt><dd>Initializer of the optimizer. The first value of initializer is the hash-table that collected model's parameter where the key is fixnum from 0 to n. You have to store it.</dd><dt>parameters</dt><dd>An parameters that it has.</dd><dt>update</dt><dd>when training and (update) is called, this slot is called and you optimizer your parameters.</dd><dt>optimize</dt><dd>when t, the :update slot is defined with (optimize (speed 3)(space 0)(debug 0)) Default: nil</dd><dt>document</dt><dd>docstring for optimizers. You can use string or (with-usage) macro</dd></dl><p>Example:</p><pre><code class="lisp">;defoptimizer's args must start with params (symbol-name doesn't matter) which receives hash-table whose key is 1..n

(defoptimizer SGD (params &amp;key (lr 1e-3))
  :optimize t
  :parameters ((params params :type hash-table)
               (lr lr :type single-float))
  :update (()
       (dotimes (i (hash-table-count (self params)))
         ; W(n+1) = W(n) - n * grad
         (!modify (gethash i (self params))) :+=
               (!mul (self lr)(grad (gethash i (self params)))))))

</code></pre><p>
</p></div></div></p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defdataset</code><code class="codex-lambda-list">(name args &amp;key parameters next length (document An dataset structure defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining dataset. (This is kinda pytorch's dataloader)</p><p>The slots you defined can be invoked by using (get-dataset dataset index)(get-length dataset).</p><dl><dt>parameters</dt><dd>parameters datasets have.</dd><dt>next</dt><dd>when function (get-dataset dataset index) is called, this slot invokes. Return waffetensor for the next batch in response to your task.</dd><dt>length</dt><dd>In this form, the function must return the total length of your datasets where the value is fixnum. (Not a batch, and not a current index.)</dd></dl><pre><code class="lisp">(defdataset Mnistdata (train valid batch-size)
  :parameters ((train train)(valid valid)(batch-size batch-size))
  :next    ((index)
	    (list (!set-batch (self train) index (self batch-size))
		  (!set-batch (self valid) index (self batch-size))))
  :length (()(car (!shape (self train)))))

</code></pre><p>cl-waffe excepts index to be 1, 2, 3, ... (dataset-maxlen)</p><p>So, please manage batch-sizes in args and :next slots.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">get-dataset</code><code class="codex-lambda-list">(dataset index)</code><div class="codex-docstring">Get datum of the index from dataset.
Input: dataset ... dataset defined by defdataset.
       index ... fixnum</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">get-dataset-length</code><code class="codex-lambda-list">(dataset)</code><div class="codex-docstring">Get total size of your dataset.</div></div></p><p><div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">deftrainer</code><code class="codex-lambda-list">(name args &amp;key model optimizer optimizer-args step-model predict (document An trainer structure defined by cl-waffe.))</code><div class="codex-docstring"><p>Defining trainer, which is made in order to call <code class="codex-param">train</code> function.</p><p>The slots you defined can be invoked by using <code>(step-model model &amp;rest args)</code>, <code>(predict model &amp;rest args)</code>. See below.</p><p>
</p><dl><dt>model</dt><dd>An model defined by <code>(defmodel)</code> which you want to train.</dd><dt>optimizer</dt><dd>An optimizer defined by <code>(defoptimizer)</code></dd><dt>optimizer-args</dt><dd>An arguments for optimizer</dd><dt>step-model</dt><dd>For each batch step, :step-model is called in <code>(train)</code> function. Describe here forward step, backward, zero-grad, update for training.</dd><dt>predict</dt><dd>an code for predicting</dd></dl><p>
These macro below are defined by <a href="http://l1sp.org/cl/macrolet"><code>macrolet</code></a> and you can use them in :step-model, :predict</p><dl><dt>(self name)</dt><dd>access trainer's parameters.</dd><dt>(model)</dt><dd>access trainer's model, defined by :model keyword.</dd><dt>(zero-grad)</dt><dd>Find model's all parameters and constants, and initialize their grads. (i.e. call optimizer's backward)</dd><dt>(update)</dt><dd>Find model's all parameters, and call optimizer and change parameter's data. (i.e. call optimizer's forward)</dd></dl><p>This trainer macro is defined in order to integrate following works:</p><ol><li>calling models</li><li>calling criterions</li><li>calling backward</li><li>calling optimizer</li><li>calling zero-grad</li><li>defining predict</li></ol><p>Example:</p><pre><code class="lisp">(deftrainer MLPTrainer (activation lr)
  :model          (MLP activation)
  :optimizer      cl-waffe.optimizers:Adam ; Note: :optimizer requires a single variable.
  :optimizer-args (:lr lr) ; these arguments directly expanded to optimizer's args.
  :step-model ((x y)
	       (zero-grad) ; call zero-grad
	       (let ((out (cl-waffe.nn:softmax-cross-entropy (call (model) x) y))) ; get criterion
		 (backward out) ; backward
		 (update) ; call optimizer
		 out)) ; return loss
 :predict ((x)(call (model) x))) ;for predict

(setq trainer (MLPTrainer :relu 1e-4)) ; init your trainer

; Train:   (step-model trainer model-input-x model-input-y)
; Predict: (predict trainer model-input-x)

</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">step-model</code><code class="codex-lambda-list">(trainer &amp;rest args)</code><div class="codex-docstring"><p>An function for calling trainer object defined by deftrainer
By using this function, trainer's step-model will be invoked.</p><p>Input: Trainer, Args</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">predict</code><code class="codex-lambda-list">(trainer &amp;rest args)</code><div class="codex-docstring">An function for calling trainer's predict slot</div></div>
</p></p><h1 id="documents-in-cl-waffe's-object">Documents in cl-waffe's object</h1>

<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-usage</code><code class="codex-lambda-list">(object-name &amp;key (overview Nothing) (args describe like &amp;rest this) (forward Nothing) (step-args describe like &amp;rest this) (backward Nothing) (update Nothing) (step-model Nothing) (predict Nothing) (next Nothing) (length Nothing) (note ))</code><div class="codex-docstring"><p>In :document slot, (for `defmodel, defnode, defoptimizer deftrainer defdataset`) this macro will be useful.</p><p>Keyword:
   step-args, arguments for :forward or :step-model, :next.</p><p>cl-waffe automatically generate docstrings.</p><p>Todo:Write Docs</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">build-docstring</code><code class="codex-lambda-list">(usage object-type)</code><div class="codex-docstring"><p>Build docstring based on usage and object-type</p><p>Todo: Write Doc</p></div></div>

<h1 id="tensor">Tensor</h1><h2 id="basic-of-tensor-and-backward">Basic of Tensor and backward</h2><h3 id="initialize-tensor">Initialize Tensor</h3><p>
Choose your data structure as follows:</p><dl><dt>use grads</dt><dd>=&gt; Initialize with (tensor ) or (parameter )</dd><dt>don't use grads</dt><dd>=&gt; Initialize with (const )</dd></dl><h4 id="parameters">Parameters</h4><pre><code class="lisp">(tensor 0) ; =&gt; #Parameter{0 :device :MGL :backward NIL}
(parameter (!zeros '(10 10)))
; =&gt; #Parameter{((0.0 0.0 ~ 0.0 0.0)            
;                         ...
;            (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10) :device :MGL :backward NIL}

(setq mat (make-mat '(10 10)))
(tensor mat) ;the save as above
</code></pre><h4 id="constants">Constants</h4><pre><code class="lisp">(const 0) ; =&gt; #Const(0)
(!zeros '(10 10)) ; =&gt;
;#Const(((0.0 0.0 ~ 0.0 0.0)        
;                 ...
;        (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))

(setq mat (make-mat '(10 10)))
(const mat) ; the same as above
</code></pre><h4 id="tensor-vs-const">Tensor vs Const</h4>
The differences between Tensor and Const are as follows
<ol><li>Calling (backward out) function, and (grad tensor) get new grads-value while (grad const) doesn't</li><li>Calling optimizers will modify the model's parameters where param is a tensor, while const isn't.</li></ol>
<p>
</p><p>In order to make constants an parameter, use this:
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">parameter</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Redefining new-tensor where old-tensor is const or tensor.</p><p>The new-tensor can made grads.</p><p>Excepted usage is like:
</p><pre><code class="lisp">(setq my-param (parameter (!mul 0.01 (!randn `(10 10)))))
</code></pre><p>Note that: tensor's computation node that old-tensor has, will be lost. Only tensor's data and backend will be extended.</p><dl><dt>Input</dt><dd>Tensor (as usual, defined by (const)(sysconst)(tensor))
</dd><dt>Output</dt><dd>Tensor (as usual, defined by (tensor))
</dd></dl></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">detach</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Create a Const with all information except data and backend erased.</p><p>This macro expanded to <code>(const (data tensor))</code>.</p><p>Note: this macro doesn't clone data itself.</p><p>Example:
</p><pre><code class="lisp">(setq a (parameter (!randn `(10 10))))
;#Parameter{((0.062... 0.716... ~ 0.088... 0.692...)            
;                         ...
;            (0.458... 0.194... ~ 0.902... 0.480...)) :mgl t :shape (10 10) :device :MGL :backward NIL}
(detach a)
;#Const(((0.062... 0.716... ~ 0.088... 0.692...)        
;                 ...
;        (0.458... 0.194... ~ 0.902... 0.480...)) :mgl t :shape (10 10))
</code></pre></div></div>
</p><p>Here's structure of waffetensor
<div class="codex-doc-node codex-record codex-structure"><code class="codex-name">waffetensor</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Constructor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(sysconst value &amp;key (backend *default-backend*) (extend nil) (thread-data nil) (path-through-node? nil) (no-jit nil) &amp;aux (data (init-waffe-tensor-data value)) (backend (check-backend backend extend)) (grad nil) (thread-data thread-data) (destructive? t) (is-sysconst? t) (force-ignore-jit no-jit) (path-through-node? path-through-node?) (is-mat (typep value (quote mat))) (grad-tmp (make-grad-tmp)))</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Predicate:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">waffetensor-p</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Copier:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">copy-waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Print Function:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(lambda (tensor stream depth) (declare (ignore depth)) (format stream (render-tensor tensor)))</code></td></tr></table></div><div class="codex-docstring"><p>An structure of Waffe's Tensor.
This structure have:
</p><ol><li>data (type of WaffeTensorContentType)</li><li>the computation node for backprops, and grads</li><li>backend informations and parameters for optimizing.</li></ol><p>There's three ways to make it.
</p><dl><dt>(const value)</dt><dd>Constant tensor, grad won't be created.</dd><dt>(tensor value)</dt><dd>Parameter tensor, grad will be created.</dd><dt>(sysconst value)</dt><dd>Constant tensor where tensor sometime cached. Users don't have to use this.</dd></dl><p>Value is following:
</p><ol><li>simple-array</li><li>mgl-mat:mat (recommended)</li><li>fixnum</li><li>float</li><li>null</li><li>cons</li><li>function (for lazy evaluation)</li><li>ratio (when make, coerced to float)</li></ol><p>This structure is printable and printed nicely.</p></div><ul class="codex-slot-list"><li class="codex-slot codex-structure-slot"><code class="codex-name">data</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensortypes</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-data</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">grad-tmp</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::grad-tmp</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-grad-tmp</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(cl-waffe::make-grad-tmp)</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">backward</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-backward</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">backend</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">keyword</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-backend</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:mgl</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">grad</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensortypes</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-grad</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">variables</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">list</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-variables</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">state</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-state</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-mat</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-mat</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-param?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-param?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-ancestor-param</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-ancestor-param</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-next-destruct?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-is-next-destruct?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">destructive?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-destructive?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">thread-data</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or cl-waffe::waffenodethread null)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-thread-data</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-sysconst?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-is-sysconst?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">path-through-node?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-path-through-node?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">tensor-ident</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or null symbol)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-tensor-ident</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">force-ignore-jit</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-force-ignore-jit</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">key</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or null cons)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-key</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">idx</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(or null symbol)</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffetensor-idx</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">is-data-destructed?</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor-is-data-destructed?</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr></table></div></li></ul></div>
</p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">backward</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Compute back propagation by traversing the Tensor's computation node.</p><p>The parameters of the model defined by (tensor) or to which (Parameter tensor) is applied, store the gradient in grad slot.</p><p>Note that: tensor must be the shape of `(1) or single value. Otherwise an error occurs.</p><p>In the process calculating backward, new backwards won't be created. (*no-grad* automatically becomes t)</p><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>NIL</dd></dl></div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*no-grad*</code><div class="codex-docstring">When t, some node will be ignored. see references below for details. default: nil</div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-no-grad</code><code class="codex-lambda-list">(&amp;body body &amp;aux (no-grad-first (gensym)))</code><div class="codex-docstring"><p>This macro is like with-predict-mode</p><p>When you predicting your models, copying values for backward is waste.</p><p>In this macro, *no-grad* become t, and won't make computation nodes.</p><p>macro (save-for-backward) is ignored and they will be faster.</p></div></div>
</p><p>
</p><h2 id="forward-nodes">Forward Nodes</h2>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">call</code><code class="codex-lambda-list">(model &amp;rest args)</code><div class="codex-docstring"><p>Calling Forward Step defined by defmodel, defnode, defoptimizer.</p><p>And building computation node as long as *no-grad* is nil.</p><dl><dt>model</dt><dd>Your initialized model/node/optimizer objects</dd><dt>args</dt><dd>The args :forward needs</dd></dl><p>Output: =&gt; <code class="codex-param">tensor</code> produced by :forward</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-calling-layers</code><code class="codex-lambda-list">(input &amp;rest layers)</code><div class="codex-docstring"><p>This macro allows to sequentially call layers.</p><p>the argument <code class="codex-param">input</code> must be a tensor.</p><p>Refering each layers from (self) macro, destructively modifying x with the returned value.</p><pre><code class="lisp">(defmodel MLP (activation)
   :parameters ((layer1   (denselayer (* 28 28) 512 T activation))
   	        (layer2   (denselayer 512 256 T activation))
	        (layer3   (linearlayer 256 10 T)))
   :forward ((x)
	     (with-calling-layers x
	       (layer1 x)
 	       (layer2 x)
               (layer3 x))))
</code></pre><p>For the different arguments.</p><pre><code class="lisp">(with-calling-layers x
     (layer1 x 1 1)
     (layer2 1 x 2)
     (layer3 x y))
</code></pre><p>Output: An last value of layers.</p></div></div>

<p>
</p><h2 id="exported-parameters">Exported Parameters</h2><p><p>
<div class="codex-doc-node codex-variable"><code class="codex-name">*default-backend*</code><div class="codex-docstring">Default backend cl-waffe uses. Default: :mgl</div></div></p><p>Configs when printing tensor.<div class="codex-doc-node codex-variable"><code class="codex-name">*print-char-max-len*</code><div class="codex-docstring">When printing tensor, the character displayed following this param.
(e.g. When 5, in your terminal, 1.12345d0 =&gt; 1.1234...)
Default: 5</div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*print-arr-max-size*</code><div class="codex-docstring">When printing tensor, the tensor displayed following this param.
(e.g. When 5, in your terminal, (1 2 3 4 5 6 7 8 9 10) =&gt; (1 2 3 ... 4 5 6))
Default: 6</div></div>
<div class="codex-doc-node codex-variable"><code class="codex-name">*print-mat-max-size*</code><div class="codex-docstring">When printing tensor, the tensor displayed following this param.
(e.g. When 3, in your terminal, ((1)(2)(3)(4)) =&gt; ((1)(2) ... (4)))</div></div>
</p></p><h2 id="types">Types</h2><p>
<div class="codex-doc-node codex-type"><code class="codex-name">waffetensorcontenttype</code><code class="codex-type-def">nil</code><div class="codex-docstring"><p>An type of data that allowed to make tensors with (const ~) or (tensor ~).</p><p>cl-waffe automatically coerce them to arbitary types</p><p>`(or mgl-mat:mat
     simple-array
     waffesupporteddatatype)</p></div></div>
<div class="codex-doc-node codex-type"><code class="codex-name">waffesupporteddatatype</code><code class="codex-type-def">nil</code><div class="codex-docstring"><p>An type of waffe-tensor's content type,</p><p>`(or fixnum float null cons function ratio)</p></div></div>

</p><h2 id="accessor">Accessor</h2><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">data</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Access tensor's data. This won't be copied.</p><p>When tensor's data is lazy evaluted, this function behave following:
</p><ol><li>When tensor is transposed and lazy evaluted, directly returns function object for speed.</li><li> When tensor is cached and lazy evaluted, returns mat object.</li></ol><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>mgl-mat:mat, or waffetensorcontentdata</dd></dl><p>when (data tensor) is a function and is:</p><dl><dt>cached mat</dt><dd>Return mgl-mat, this do not make copy</dd><dt>lazy-evaluation or transposed</dt><dd>Return function itself</dd></dl><p>Note: this function is setfable and inlined</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">grad</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Accessing tensor's grad.</p><p>When tensor's grad is nil, an error occurs</p><dl><dt>Input</dt><dd>WaffeTensor</dd><dt>Output</dt><dd>An tensor's grad which is the type of mgl-mat:mat or waffetensorcontettype</dd></dl><p>Note: grad is <b>not</b> setfable</p></div></div>
</p><p>
</p><p>
</p><h1 id="initialize-constants">Initialize Constants</h1><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!zeros</code><code class="codex-lambda-list">(shape)</code><div class="codex-docstring"><p>Initializing constant tensor with given shape, where initial elements are zero.</p><p>Input: shape (cons)</p><p>Output: Tensor (which is constant)</p><p>Example:
</p><pre><code class="lisp">(!zeros `(10 10))
;#Const(((0.0 0.0 ~ 0.0 0.0)        
;                ...
;        (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!ones</code><code class="codex-lambda-list">(shape)</code><div class="codex-docstring"><p>The same as !zeros but initial element is one.</p><p>Example:
</p><pre><code class="lisp">(!ones `(10 10))
;#Const(((1.0 1.0 ~ 1.0 1.0)        
;                ...
;        (1.0 1.0 ~ 1.0 1.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!fill</code><code class="codex-lambda-list">(shape element)</code><div class="codex-docstring"><p>The same as !zeros, !ones but initial element is given element.</p><p>Note: the argument <code class="codex-param">element</code> coerced into <code class="codex-param">mgl-mat:*default-mat-ctype*</code></p><p>Example:
</p><pre><code class="lisp">(!fill '(10 10) 10)
;#Const(((10.0 10.0 ~ 10.0 10.0)        
;                  ...
;        (10.0 10.0 ~ 10.0 10.0)) :mgl t :shape (10 10))
</code></pre><p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">!arange</code><code class="codex-lambda-list">(&amp;rest args)</code><div class="codex-docstring"><p>Like numpy's arange, arange can be called with a varying number of positional arguments:</p><h2 id="(-!arange-stop-)">(!arange stop)</h2>
<pre><code class="lisp">(!arange 10)
;#Const((0.0 1.0 ~ 8.0 9.0) :mgl t :shape (10))
</code></pre>
<h2 id="(-!arange-start-stop-)">(!arange start stop)</h2>
<pre><code class="lisp">(!arange 3 10)
;=&gt;#Const((3.0 4.0 ~ 8.0 9.0) :mgl t :shape (7))
</code></pre>
<h2 id="(-!arange-start-stop-step-)">(!arange start stop step)</h2>
<pre><code class="lisp">(!arange 3 10 2)
;#Const((3.0 5.0 7.0 9.0) :mgl t :shape (4))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!random</code><code class="codex-lambda-list">(dims limit)</code><div class="codex-docstring"><p>Initialize an tensor of dims (cons)</p><p>!random can be called with a varying number of type of arguments:</p><h2 id="when-limit=fixnum">When limit=fixnum</h2><p>
init within the range of <code>0&lt;=x&lt;limit</code></p><pre><code class="lisp">;#Const(((1.0 2.0 ~ 2.0 1.0)        
;                 ...
;        (2.0 2.0 ~ 2.0 2.0)) :mgl t :shape (10 10))
</code></pre><p>
</p><h2 id="when-limit=single-float">When limit=single-float</h2>
init within the range of <code>0&lt;=x&lt;limit</code>
<pre><code class="lisp">(!random '(10 10) 3.0)
;#Const(((0.152... 2.203... ~ 2.360... 2.216...)        
;                 ...
;        (1.003... 2.257... ~ 2.305... 2.025...)) :mgl t :shape (10 10))
</code></pre>
<h2 id="when-limit=-(-cons-single-float1-single-float2-)">When limit=(cons single-float1 single-float2)</h2>
init with single-float1&lt;=x&lt;single-float2, where each element is single-float.
<pre><code class="lisp">(!random '(10 10) '(1.0 3.0))
;#Const(((1.982... 1.526... ~ 1.388... 1.312...)        
;                 ...
;        (1.829... 2.676... ~ 1.226... 2.980...)) :mgl t :shape (10 10))
</code></pre>
<p>Return: WaffeTensor
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!random-with</code><code class="codex-lambda-list">(dims f)</code><div class="codex-docstring"><p>Initializes the tensor of dims. Each element is initialized with <code class="codex-param">f</code> where f is a lambda exp and called with index.</p><p>Warning: Using mref and slow algorithm, <b>it is so slow</b>.</p><p>Example:
</p><pre><code class="lisp">(!random-with '(10 10) #'(lambda (n) n))
;#Const(((0.0 1.0 ~ 8.0 9.0)        
;                 ...
;        (90.0 91.0 ~ 98.0 99.0)) :mgl t :shape (10 10))
</code></pre><p>See also: !init-with which is alias for !random-with.
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!normal</code><code class="codex-lambda-list">(dims &amp;optional (mean 2.0) (var 1.0))</code><div class="codex-docstring"><p>Init with normal distribution.</p><p>Warning: Using mref and slow algorithm, <b>its sooo slow.</b></p><p>It is recommended to use !randn and transform it instead.</p></div></div>
<div class="codex-error codex-no-node">No node with name <code>!randn</code>.</div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!beta</code><code class="codex-lambda-list">(dims alpha beta)</code><div class="codex-docstring"><p>Initializes tensor with samples of beta distribution in a faster way.</p><p>Algorithm: https://dl.acm.org/doi/pdf/10.1145/359460.359482</p><p>x=[0,1]</p><p>a = min(alpha, beta)</p><p>b = max(alpha, beta)</p><p>PDF: fX(x)=x^a−1*(1−x)*b−1/B(a,b)</p><p>where B(a,b)=∫1,0{x^a−1(1−x)^b−1}dx</p><pre><code class="lisp">(time (!beta '(200) 5.0 1.0))
;Evaluation took:
;  0.000 seconds of real time
;  0.000063 seconds of total run time (0.000063 user, 0.000000 system)
;  100.00% CPU
;  143,846 processor cycles
;  0 bytes consed
  
;#Const((0.813... 0.832... ~ 0.865... 0.787...) :mgl t :shape (200))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!gamma</code><code class="codex-lambda-list">(dims k &amp;optional (theta 1.0))</code><div class="codex-docstring"><p>Initialize tensor with samples of gamma distribution.</p><p>Todo: Use fast algorithms and approximations in response to <code class="codex-param">k</code>.</p><p>Example:
</p><pre><code class="lisp">(!gamma '(10 10) 1.0)
;#Const(((2.155... 3.374... ~ 1.274... 0.147...)        
;                 ...
;        (0.194... 0.081... ~ 0.816... 0.209...)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!chisquare</code><code class="codex-lambda-list">(dims df)</code><div class="codex-docstring"><p><b>Not implemented yet</b>
Todo: Use fast algorithms and approximations.</p><p>Example:
</p><pre><code class="lisp"></code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!bernoulli</code><code class="codex-lambda-list">(dims rate)</code><div class="codex-docstring"><p>Init a tensor of dims with bernoulli</p><p>rate is single-float, and [0 1]</p><p>See also: <code class="codex-param">!binomial</code>, alias for it.</p><p>Example:
</p><pre><code class="lisp">(!binomial '(10 10) 0.5)
;#Const(((1.0 0.0 ~ 1.0 1.0)        
;                 ...
;        (0.0 1.0 ~ 1.0 0.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!zeros-like</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Return a const where the shape is the same as tensor but elements are zero.</p><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10)))
(!zeros-like a)
;#Const(((0.0 0.0 ~ 0.0 0.0)        
;                 ...
;        (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!ones-like</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring">Return a const where the shape is the same as tensor but elements are one.
Example:
<pre><code class="lisp">(setq a (!randn `(10 10)))
(!ones-like a)
;#Const(((1.0 1.0 ~ 1.0 1.0)        
;                 ...
;        (1.0 1.0 ~ 1.0 1.0)) :mgl t :shape (10 10))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!full-like</code><code class="codex-lambda-list">(tensor element)</code><div class="codex-docstring">Return a const where the shape is the same as tensor but elements are specified value by <code class="codex-param">element</code>.
Example:
<pre><code class="lisp">(setq a (!randn `(10 10)))
(!full-like a 3)
;#Const(((3.0 3.0 ~ 3.0 3.0)        
;                 ...
;        (3.0 3.0 ~ 3.0 3.0)) :mgl t :shape (10 10))
</code></pre></div></div>
</p><p>
</p><h1 id="cut-and-displace-tensor">Cut and Displace Tensor</h1>
<p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!set-batch</code><code class="codex-lambda-list">(dataset start-row-index batch-size)</code><div class="codex-docstring"><p>Set batch where dataset is a 2d mat.</p><p>Todo: Backward.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!reset-batch</code><code class="codex-lambda-list">(dataset)</code><div class="codex-docstring">Reset batch of dataset (i.e.: reset dataset's displacement)</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!aref</code><code class="codex-lambda-list">(tensor &amp;rest dims)</code><div class="codex-docstring"><p>Very fast aref.</p><p>This function is setfable.</p><p>Cuts the area specified by dims from Tensor and generates a new Const.</p><p>This function creates computation node.</p><p>dims are following:
</p><ol><li>fixnum</li><li>t ... which means 0 ... maxlen</li><li>Cons (e.g. '(1 3) reads 1&lt;=x&lt;3)
</li></ol><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10)))

;=&gt; #Const(((0.280... 1.941... ~ 0.723... -0.47...)        
;                   ...
;          (-1.01... 0.232... ~ -1.16... 0.405...)) :mgl t :shape (10 10))

(!aref a '(0 3) t)
(!aref a t '(0 3))
(!aref a 1 1)
(setq a (setf (!aref a '(0 3) '(0 3))(!zeros '(3 3)))) ; to update nodes

</code></pre></div></div>
</p>
<h1 id="shaping">Shaping</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!shape</code><code class="codex-lambda-list">(tensor &amp;optional (nth nil))</code><div class="codex-docstring"><p>Returns the shape of tensor when nth=nil.<code class="codex-param">nth</code> indicates the index of shape, !shape return specified value.</p><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10 10)))
(!shape a) ; =&gt; (10 10 10)
(!shape a 0) ;=&gt; 10
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!dims</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Returns the total length of a given tensor's dims</p><p>Example:
</p><pre><code class="lisp">(!dims (!zeros '(10 10 10))) ; =&gt; 3
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!size</code><code class="codex-lambda-list">(tensor)</code><div class="codex-docstring"><p>Returns the total size of a tensor</p><p>Example:
</p><pre><code class="lisp">(!size (!zeros '(10 10 10))) ; =&gt; 1000
</code></pre></div></div>

<h1 id="operations">Operations</h1><p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!add</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Adds x and y.</p><p>In the case when x or y is not a tensor, automatically creates a new tensor.</p><p>It supports:</p><ol><li>Broadcasting shapes</li><li>JIT</li></ol><h2 id="examples">Examples</h2>
<pre><code class="lisp">(setq a (!randn `(3 3)))
(setq b (!randn `(3 3)))
(setq c (!randn `(3 1)))

(!add 1 1)
;=&gt; Const(2)

(!add (const 1)(const 1))
;=&gt; Const(2)

(!add a b)
;#Const(((3.418... 1.974... 0.177...)
;                 ...
;        (-1.30... 0.987... 1.917...)) :mgl t :shape (3 3))

(!add a c)
;#Const(((1.426... 2.129... 1.050...)
;                 ...
;        (-0.64... 0.269... 0.303...)) :mgl t :shape (3 3))

</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sub</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Subtract x by y.</p><p>In the case when x or y is not a tensor, automatically creates a new tensor.</p><p>It supports:</p><ol><li>Broadcasting shapes</li><li>JIT</li></ol><h2 id="1-examples">Examples</h2>
<pre><code class="lisp">(setq a (!randn `(3 3)))
(setq b (!randn `(3 3)))
(setq c (!randn `(3 1)))

(!sub 1 1)
;=&gt; Const(0)

(!sub (const 1)(const 1))
;=&gt; Const(0)

(!sub a b)
;#Const(((-0.86... 1.413... 1.139...)
;                 ...
;        (0.017... -0.44... -1.31...)) :mgl t :shape (3 3))

(!sub a c)
;#Const(((1.128... 1.258... 0.267...)
;                 ...
;        (-0.64... 0.269... 0.303...)) :mgl t :shape (3 3))

</code></pre>
<p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!mul</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Multiply x and y with element-wise.</p><p>In the case when x or y is not a tensor, automatically creates a new tensor.</p><p>It supports:</p><ol><li>Broadcasting shapes</li><li>JIT</li></ol><h2 id="2-examples">Examples</h2>
<pre><code class="lisp">(setq a (!randn `(3 3)))
(setq b (!randn `(3 3)))
(setq c (!randn `(3 1)))

(!mul 1 1)
;=&gt; Const(1)

(!mul (const 1)(const 1))
;=&gt; Const(1)

(!mul a b)
;#Const(((2.734... 0.475... -0.31...)        
;                 ...
;        (0.426... 0.193... 0.490...)) :mgl t :shape (3 3))

(!mul a c)
;#Const(((2.734... 0.475... -0.31...)        
;                 ...
;        (0.426... 0.193... 0.490...)) :mgl t :shape (3 3))

</code></pre>
<p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!div</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Divides x by y.</p><p>In the case when x or y is not a tensor, automatically creates a new tensor.</p><p>It supports:</p><ol><li>Broadcasting shapes</li><li>JIT</li></ol><h2 id="3-examples">Examples</h2>
<pre><code class="lisp">(setq a (!randn `(3 3)))
(setq b (!ones `(3 3)))
(setq c (!ones `(3 1)))

(!div 2 1)
;=&gt; Const(2)

(!div (const 2)(const 1))
;=&gt; Const(2)

(!div a b)
;#Const(((1.734... 0.475... -0.31...)        
;                 ...
;        (0.426... 0.193... 0.490...)) :mgl t :shape (3 3))

(!div a c)
;#Const(((2.734... 0.475... -0.31...)        
;                 ...
;        (0.426... 0.193... 0.490...)) :mgl t :shape (3 3))

</code></pre>
<p>
</p></div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!matmul</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Multiplying matrices <code class="codex-param">x</code> and <code class="codex-param">y</code>.</p><p>!matmul has many behaviours depends on the dimensionality of the tensors as follows:</p><dl><dt>x and y are 1D</dt><dd>The dot-product is returned.
<pre><code class="lisp">(setq a (!randn `(10)))
(setq b (!randn `(10)))
(!matmul a b)
;=&gt;#Const(-2.0)
</code></pre>
</dd><dt>x and y are both 2D</dt><dd>The matrix-matrix product is returned.
<pre><code class="lisp">(setq a (!randn `(3 10)))
(setq b (!randn `(10 3)))
(!matmul a b)
;#Const(((2.309... 2.223... 3.630...)        
;                 ...
;        (2.334... 2.850... 3.678...)) :mgl t :shape (3 3))
</code></pre>
</dd><dt>x is 2D and y is 3D.</dt><dd>The matrix and y's each matrix are multiplied and is returned.
<pre><code class="lisp">(setq a (!randn `(3 10)))
(setq b (!randn `(5 10 3)))

(!matmul a b)
;(!aref b 0) ~ (!aref b 4) is multiplied with a

;#Const((((3.257... 2.731... 1.670...)         
;                   ...
;         (2.523... 2.251... 1.276...))        
;                 ...
;        ((2.610... 2.764... 2.415...)         
;                   ...
;         (2.080... 2.204... 1.751...))) :mgl t :shape (5 3 3))
</code></pre>
</dd><dt>x is 3D and y is 2D.</dt><dd>The matrix and x's each matrix are multiplied and is returned.
<pre><code class="lisp">(setq a (!randn `(5 3 10)))
(setq b (!randn `(10 3)))

(!matmul a b)
;(!aref a 0) ~ (!aref a 4) is multiplied with b
;#Const((((2.309... 2.204... 1.556...)         
;                   ...
;         (3.746... 3.869... 3.091...))        
;                 ...
;        ((3.260... 3.200... 2.847...)         
;                   ...
;         (3.008... 2.186... 2.376...))) :mgl t :shape (5 3 3))
</code></pre>
</dd><dt>For more...</dt><dd>More will be added (e.g.: 1d and 2d, for larger than 4d ...)</dd></dl></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!dot</code><code class="codex-lambda-list">(x y)</code><div class="codex-docstring"><p>Computes the dot product of x and y where x and y are 1d Tensor.</p><p>🗒Note: Unlike Numpy's dot, !dot only supports for 1d tensors with the same number of elements and the tensor of which dims is larger than 1, regarded as 1d tensors.</p><h2 id="example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10)))
(setq b (!randn `(10)))

(!dot a b)
;=&gt; #Const(1.0842022e-19)
</code></pre>
<p>
</p></div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!pow</code><code class="codex-lambda-list">(x n)</code><div class="codex-docstring">Takes the power of each element in <code class="codex-param">x</code> with n, returning a new sysconst.<h2 id="4-example">Example</h2>
<pre><code class="lisp">(setq a (!ones `(10 10)))
(!pow a 3)
;#Const(((1.0 1.0 ~ 1.0 1.0)        
;                 ...
;        (1.0 1.0 ~ 1.0 1.0)) :mgl t :shape (10 10))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sqrt</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Takes the power of eachelement in <code class="codex-param">x</code> with 1/2, creating new sysconst and nodes.<h2 id="5-example">Example</h2>
<pre><code class="lisp">(setq a (!ones `(10 10)))
(!sqrt a 3)
;#Const(((1.0 1.0 ~ 1.0 1.0)
;                 ...
;        (1.0 1.0 ~ 1.0 1.0)) :mgl t :shape (10 10))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!log</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Returns a new tensor with the natural logarithm of the elements of input.</p><p>yi = log(e xi)</p><h2 id="6-example">Example</h2>
<pre><code class="lisp">(setq a (!ones '(10 10)))
(!log a)
;#Const(((0.0 0.0 ~ 0.0 0.0)        
;                 ...
;        (0.0 0.0 ~ 0.0 0.0)) :mgl t :shape (10 10))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!exp</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Applying exp to each element of x, creating a new sysconst.<h2 id="7-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10 10)))
;#Const(((0.624... 0.807... ~ 0.500... 0.937...)        
;                 ...
;        (0.662... 0.299... ~ 0.761... 0.729...)) :mgl t :shape (10 10))
(!exp a)
;#Const(((1.866... 2.242... ~ 1.650... 2.553...)        
;                 ...
;        (1.939... 1.349... ~ 2.140... 2.073...)) :mgl t :shape (10 10))
</code></pre>
</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sum</code><code class="codex-lambda-list">(x &amp;optional (axis nil) (keepdims nil))</code><div class="codex-docstring"><p>Sum up x where x is a cl-waffe tensor.</p><p>For nd tensors...
</p><dl><dt>1D</dt><dd>unsqueeze x with 1, and call !sum again.</dd><dt>2D and more.</dt><dd>Sum up all elements of X</dd></dl><h2 id="arguments">arguments</h2><dl><dt>axis</dt><dd>a dimension to reduce</dd><dt>keepdims</dt><dd>When t, the returning tensor is repeated with <code class="codex-param">axis</code></dd></dl><h2 id="8-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10)))
(!sum a)
;=&gt;#Const(4.74653)

(setq a (!randn `(10 10)))
(!sum a)
;=&gt;#Const(1.5428619)

(!sum a 0)
;=&gt;#Const(((-2.07... 0.463... ~ 1.778... 1.695...)) :mgl t :shape (1 10))

(!sum a 1)
;#Const(((0.967...)        
;                 ...
;        (2.774...)) :mgl t :shape (10 1))

(!sum a 0 t)
;#Const(((-2.07... 0.463... ~ 1.778... 1.695...)        
;                 ...
;        (-2.07... 0.463... ~ 1.778... 1.695...)) :mgl t :shape (10 10))
</code></pre>
<p>
</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!mean</code><code class="codex-lambda-list">(x &amp;optional (axis nil) (keepdims nil))</code><div class="codex-docstring">The usage is the same as !sum.<h2 id="9-example">Example</h2>
<pre><code class="lisp">(setq a (!ones '(10 10)))
;#Const(((1.0 1.0 ~ 1.0 1.0)        
;                 ...
;        (1.0 1.0 ~ 1.0 1.0)) :mgl t :shape (10 10))
(!mean a)
;=&gt;Const(1.0)
</code></pre>
</div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!modify</code><code class="codex-lambda-list">(target instruction &amp;rest args)</code><div class="codex-docstring"><p>The function that allows destructively operations, always changing the target.</p><p>If you need mgl-mat-wise operations for speed and low memory, this is useful.</p><p>Directly Calling Mgl-mat Operations.</p><p>Please remain that it won't make backwards because of speed problems.(Todo: Fix)</p><p>Always return `target` tensor. target always changed, and args sometimes changed</p><p>Instruction is a symbol where described with modify:</p><p>Todo: Write more details.</p><p>Example:</p><pre><code class="lisp">(!modify x :+= y)
</code></pre></div></div></p><p>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!squeeze</code><code class="codex-lambda-list">(x &amp;optional (dim nil))</code><div class="codex-docstring"><p>Returns a new tensor with a dimension of size one removed at the specified position.</p><p>When dim=nil or -1, the last position of dim will be removed.</p><p>If the specified position of a tensor isn't one, !squeeze is skipped.</p><h2 id="10-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10 1 10)))
;#Const((((0.928... 0.556... ~ 0.697... 0.973...))        
;                 ...
;        ((0.368... 0.995... ~ 0.589... 0.716...))) :mgl t :shape (10 1 10))

(!squeeze a 1)
;#Const(((0.928... 0.556... ~ 0.697... 0.973...)        
;                 ...
;        (0.368... 0.995... ~ 0.589... 0.716...)) :mgl t :shape (10 10))

(!squeeze a -1)
;#Const((((0.928... 0.556... ~ 0.697... 0.973...))        
;                 ...
;        ((0.368... 0.995... ~ 0.589... 0.716...))) :mgl t :shape (10 1 10))

(setq a (!randn `(10 10 1)))
;#Const(((0.991... 0.248... ~ 0.610... 0.289...)        
;                 ...
;        (0.593... 0.177... ~ 0.374... 0.668...)) :mgl t :shape (10 10))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!unsqueeze</code><code class="codex-lambda-list">(x &amp;optional (dim 0))</code><div class="codex-docstring"><p>Returns a new tensor with a dimension of size one inserted at the specified position.</p><p>dim indicates the position, when dim=-1, it indicates a last dimension of <code class="codex-param">x</code>.</p><h2 id="11-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10 10)))
;#Const(((0.685... 0.827... ~ 0.076... 0.102...)        
;                 ...
;        (0.802... 0.571... ~ 0.207... 0.283...)) :mgl t :shape (10 10))
(!unsqueeze a)
;#Const((((0.685... 0.827... ~ 0.076... 0.102...)         
;                   ...
;         (0.802... 0.571... ~ 0.207... 0.283...))) :mgl t :shape (1 10 10))

(!unsqueeze a -1)
;#Const((((0.685...)         
;                   ...
;         (0.102...))        
;                 ...
;        ((0.802...)         
;                   ...
;         (0.283...))) :mgl t :shape (10 10 1))

(!unsqueeze a 2)
;#Const(((0.685... 0.827... ~ 0.076... 0.102...)        
;                 ...
;        (0.802... 0.571... ~ 0.207... 0.283...)) :mgl t :shape (10 10 1 1))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!repeats</code><code class="codex-lambda-list">(x axis repeats)</code><div class="codex-docstring">Repeats <code class="codex-param">x</code> along specified <code class="codex-param">axis</code> by <code class="codex-param">repeats</code>, creating new sysconst.<h2 id="12-example">Example</h2>
<pre><code class="lisp">(setq a (!randn '(1 3 3)))
;#Const((((0.333... 0.914... 0.260...)         
;                   ...
;         (0.611... 0.110... 0.113...))) :mgl t :shape (1 3 3))
(!repeats a 0 3)
;#Const((((0.333... 0.914... 0.260...)         
;                   ...
;         (0.611... 0.110... 0.113...))        
;                 ...
;        ((0.333... 0.914... 0.260...)         
;                   ...
;         (0.611... 0.110... 0.113...))) :mgl t :shape (3 3 3))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!reshape</code><code class="codex-lambda-list">(x dim)</code><div class="codex-docstring"><p>Return a new sysconst with changing its shape. x won't be modified.</p><p>If dims has the element of <code class="codex-param">t</code>, t is automatically inferred from the remaining dimensions and the number of elements in dim. (count t dim) must be 1 (Todo: Fix).</p><p>The total size of tensor must not be changed before or after the call to reshape.</p><p>See also: nil</p><h2 id="13-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(10 10 10)))
(!reshape a '(1 10 100))
;#Const((((0.454... 0.277... ~ 0.536... 0.135...)         
;                   ...
;         (0.857... 0.714... ~ 0.169... 0.279...))) :mgl t :shape (1 10 100))

(!reshape a '(1 1 t))
;#Const((((0.454... 0.277... ~ 0.169... 0.279...))) :mgl t :shape (1 1 1000))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!transpose</code><code class="codex-lambda-list">(x &amp;optional result)</code><div class="codex-docstring"><p>Transpose x where x is a 2d tensor.</p><p>Transposed x is lazy evaluated until called by !matmul.</p><p>Todo: implement 3d, 4d version...</p><h2 id="14-example">Example</h2>
<pre><code class="lisp">(setq a (!randn `(3 5)))
(setq a (!transpose a))
;#Const(#&lt;FUNCTION (LABELS CL-WAFFE.BACKENDS.MGL::LAZYTRANSPOSE :IN CL-WAFFE.BACKENDS.MGL::LAZY-EVAL-TRANSPOSE) {10038CBADB}&gt;)

(!matmul a (!randn '(3 5)))
;#Const(((0.653... 0.400... 0.471... 0.705... 0.623...)        
;                 ...
;        (1.220... 0.760... 0.975... 1.360... 1.029...)) :mgl t :shape (5 5))
</code></pre>
</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!aref</code><code class="codex-lambda-list">(tensor &amp;rest dims)</code><div class="codex-docstring"><p>Very fast aref.</p><p>This function is setfable.</p><p>Cuts the area specified by dims from Tensor and generates a new Const.</p><p>This function creates computation node.</p><p>dims are following:
</p><ol><li>fixnum</li><li>t ... which means 0 ... maxlen</li><li>Cons (e.g. '(1 3) reads 1&lt;=x&lt;3)
</li></ol><p>Example:
</p><pre><code class="lisp">(setq a (!randn `(10 10)))

;=&gt; #Const(((0.280... 1.941... ~ 0.723... -0.47...)        
;                   ...
;          (-1.01... 0.232... ~ -1.16... 0.405...)) :mgl t :shape (10 10))

(!aref a '(0 3) t)
(!aref a t '(0 3))
(!aref a 1 1)
(setq a (setf (!aref a '(0 3) '(0 3))(!zeros '(3 3)))) ; to update nodes

</code></pre></div></div></p><p><div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!modify</code><code class="codex-lambda-list">(target instruction &amp;rest args)</code><div class="codex-docstring"><p>The function that allows destructively operations, always changing the target.</p><p>If you need mgl-mat-wise operations for speed and low memory, this is useful.</p><p>Directly Calling Mgl-mat Operations.</p><p>Please remain that it won't make backwards because of speed problems.(Todo: Fix)</p><p>Always return `target` tensor. target always changed, and args sometimes changed</p><p>Instruction is a symbol where described with modify:</p><p>Todo: Write more details.</p><p>Example:</p><pre><code class="lisp">(!modify x :+= y)
</code></pre></div></div>
</p></p><h1 id="math-functions">Math Functions</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!tanh</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Applying tanh to x, return a new sysconst with making nodes.</div></div>

<h1 id="activations">Activations</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!relu</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Applying relu to x, return a new sysconst with making nodes.</p><p>Relu(x) = { 0 (x &lt; 0), x (x &gt; 0) }</p><p>Input: x where x is waffe supported data type.</p><p>Output: Tensor</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!sigmoid</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring"><p>Applyong sigmoid to x, return a new sysconst with making nodes.</p><p>Input: x where x is waffe supported data type.</p><p>Output: Tensor</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!tanh</code><code class="codex-lambda-list">(x)</code><div class="codex-docstring">Applying tanh to x, return a new sysconst with making nodes.</div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">!softmax</code><code class="codex-lambda-list">(x &amp;key (avoid-overflow t))</code><div class="codex-docstring">Nothing here</div></div>

<h1 id="utils-for-defnode">Utils for defnode</h1>
These features for advanced.
<div class="codex-error codex-no-node">No node with name <code>warranty</code>.</div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">with-kernel-case</code><code class="codex-lambda-list">(target var &amp;key (mgl nil) (mgl-cuda nil) (copy t) &amp;aux (out (gensym)))</code><div class="codex-docstring"><p>Reading the target's device, this macro invokes property codes described in :mgl, :mgl-cuda etc...</p><p>   Dynamically defining and caching cpu and cuda kernel.</p><p>   Every time reaches this macro, cl-waffe caches the target (i.e. the target is allowed to be destructed).</p><p>   This macro won't create computation nodes.</p><p>   The available slot is in *kernels*</p><p>   When :mgl-cuda is nil, automatically calls :mgl</p><p>   This macro returns the last value of called slots.</p><p>   The last value of :mgl, :mgl-cuda and so on, must be type of list (cons), or mgl-mat:mat, waffetensorcontenttype.</p><p>   Note: the target's thread-data must be already created. (i.e. By the time tensors reach this macro, at least once they needed to be pathed through Trainer or Model.)
   So, use this macro when you defining :forward and :backward in defnode macro because in defnode, backprop is disabled and computation nodes isn't always required.</p><p>Inputs
</p><dl><dt>target</dt><dd>an target tensor.</dd><dt>var</dt><dd>where an copied tensor of target will be assigned.</dd><dt>:mgl</dt><dd>mgl-mat, when using cpu.</dd><dt>:mgl-mat</dt><dd>mgl-mat, when using cuda.</dd></dl><p>Return: An tensor (where tensor is made by sysconst)</p><p>Example:</p><pre><code class="lisp">(with-kernel-case x o
     :mgl (progn
            (axpy! 1.0 a o)) ; axpy! = !add
     :mgl-cuda nil) =&gt; #Const(((0.0 1.0 ~ 2.0 3.0)        
                 ...
      (0.0 4.0 ~ 5.0 6.0)) :mgl t :shape (10 10))

 ; This is useful when defining :backward
 (with-kernel-case x o
     :mgl (progn
            (list 1 1)))
</code></pre></div></div>
<div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">call-and-dispatch-kernel</code><code class="codex-lambda-list">(kernel-function &amp;rest args)</code><div class="codex-docstring">Invoke kernel and run kernel-function. return new sysconst
It's the most general way for users to access cl-waffe's kernel.
Todo:More Details</div></div>

<h1 id="train-and-valid">Train And Valid</h1>

<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">train</code><code class="codex-lambda-list">(trainer dataset &amp;key (valid-dataset nil) (valid-each 100) (enable-animation t) (epoch 1) (batch-size 1) (max-iterate nil) (verbose t) (stream t) (progress-bar-freq 1) (save-model-path nil) (width 45) (random nil) (height 10) (print-each 10))</code><div class="codex-docstring"><p>Trainining given trainer. If any, valid <code class="codex-param">valid-dataset</code></p><dl><dt>trainer</dt><dd>Trainer you defined by deftrainer</dd><dt>dataset</dt><dd>Dataset you defined by defdataset</dd><dt>valid-dataset</dt><dd>If valid-dataset=your dataset, use this to valid. If nil, ignored</dd><dt>enable-animation</dt><dd>Ignored</dd><dt>epoch</dt><dd>Iterate training by epoch, default=1</dd><dt>batch-size</dt><dd>Do batch training. default=1</dd><dt>verbose</dt><dd>if t, put log to stream</dd></dl><p>This function is temporary and other arguments are ignored.</p><p>And this function has a lot of todo.</p></div></div>
<div class="codex-doc-node codex-operator codex-function"><code class="codex-name">valid</code><code class="codex-lambda-list">(trainer dataset batch-size)</code><div class="codex-docstring">Valid trainer</div></div>

<h1 id="datasets">Datasets</h1>

<div class="codex-doc-node codex-record codex-structure"><code class="codex-name">waffedataset</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Constructor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(waffedataset train valid &amp;key (batch-size 1) &amp;aux (train train) (valid valid) (batch-size batch-size))</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Predicate:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">waffedataset-p</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Copier:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">copy-waffedataset</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Print Function:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">print-dataset</code></td></tr></table></div><div class="codex-docstring"><h2 id="15-cl-waffe's-dataset--waffedataset">cl-waffe's Dataset: WaffeDataSet</h2>
<b>This structure is an cl-waffe object</b> 
<dl><dt>Overview</dt><dd>The standard dataset for 2d training data.</dd><dt>How to Initialize</dt><dd><pre><code class="lisp">(WaffeDataSet train valid &amp;key (batch-size 1)) =&gt; [DATASET: WaffeDataSet]
</code></pre>
</dd><dt>get-dataset</dt><dd><pre><code class="lisp">(get-dataset WaffeDataSet index) ; =&gt; Next Batch
</code></pre>
</dd><dt>get-dataset-length</dt><dd><pre><code class="lisp">(get-dataset-length WaffeDataSet) ; =&gt; Total length of WaffeDataSet
</code></pre>
</dd><dt>Object's slots</dt><dd></dd></dl>
</div><ul class="codex-slot-list"><li class="codex-slot codex-structure-slot"><code class="codex-name">train</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-train</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:train</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">valid</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe:waffetensor</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-valid</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::valid</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">batch-size</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">fixnum</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-batch-size</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::batch-size</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">length</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-length</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr></table></div></li><li class="codex-slot codex-structure-slot"><code class="codex-name">dataset-next</code><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">boolean</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Read Only:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Accessor:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">cl-waffe::waffedataset-dataset-next</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initform:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">t</code></td></tr></table></div></li></ul></div>


      </div>
    </main>
  </article>
  <footer>
    <div class="info">
      Created with <a href="https://github.com/CommonDoc/codex">Codex</a>.
    </div>
  </footer>
  <script>
   HighlightLisp.highlight_auto();
  </script>

  </body>
</html>
